////////////////////////////////////////////////////////////////////////////////
// Project Name:	CoCo3FPGA Version 3.0
// File Name:		coco3fpga.v
//
// CoCo3 in an FPGA
//
// Revision: 3.0 08/15/15
////////////////////////////////////////////////////////////////////////////////
//
// CPU section copyrighted by John Kent
// The FDC co-processor copyrighted Daniel Wallner.
//
////////////////////////////////////////////////////////////////////////////////
//
// Color Computer 3 compatible system on a chip
//
// Version : 3.0
//
// Copyright (c) 2008 Gary Becker (gary_l_becker@yahoo.com)
//
// All rights reserved
//
// Redistribution and use in source and synthezised forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// Redistributions in synthesized form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// Neither the name of the author nor the names of other contributors may
// be used to endorse or promote products derived from this software without
// specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// Please report bugs to the author, but before you do so, please
// make sure that this is not a derivative work and that
// you have the latest version of this file.
//
// The latest version of this file can be found at:
//      http://groups.yahoo.com/group/CoCo3FPGA
//
// File history :
//
//  1.0			Full Release
//  2.0			Partial Release
//  3.0			Full Release
//  3.0.0.1		Update to fix DoD interrupt issue
//	 3.0.1.0		Update to fix 32/40 CoCO3 Text issue and add 2 Meg max memory
////////////////////////////////////////////////////////////////////////////////
// Gary Becker
// gary_L_becker@yahoo.com
////////////////////////////////////////////////////////////////////////////////

module coco3fpga_dw(
// Input Clocks
CLK50MHZ,
CLK24MHZ,
CLK24MHZ_2,
CLK27MHZ,
CLK27MHZ_2,
CLK3_57MHZ,
// RAM and ROM
RAM0_DATA,				// 16 bit data bus to RAM 0
RAM0_ADDRESS,
RAM0_RW_N,
RAM0_CS_N,				// Chip Select for RAM 0
RAM0_BE0_N,				// Byte Enable for RAM 0
RAM0_BE1_N,				// Byte Enable for RAM 0
RAM0_OE_N,
RAM1_ADDRESS,
RAM1_ADDRESS9_1,
RAM1_ADDRESS10_1,
RAM1_DATA,
RAM1_BE0_N,
RAM1_BE1_N,
RAM1_BE2_N,
RAM1_BE3_N,
RAM1_CS0_N,
RAM1_CS1_N,
RAM1_RW0_N,
RAM1_RW1_N,
RAM1_OE0_N,
RAM1_OE1_N,

FLASH_ADDRESS,
FLASH_DATA,
FLASH_WE_N,
FLASH_RESET_N,
FLASH_CE_N,
FLASH_OE_N,
// SDRAM
SDRAM_ADDRESS,
SDRAM_BANK,
SDRAM_DATA,
SDRAM_LDQM,
SDRAM_UDQM,
SDRAM_RAS_N,
SDRAM_CAS_N,
SDRAM_CKE,
SDRAM_CLK,
SDRAM_CS_N,
SDRAM_RW_N,
// VGA
RED3,
GREEN3,
BLUE3,
RED2,
GREEN2,
BLUE2,
RED1,
GREEN1,
BLUE1,
RED0,
GREEN0,
BLUE0,
H_SYNC,
V_SYNC,
// PS/2
ps2_clk,
ps2_data,
//ms_clk,
//ms_data,
//Serial Ports
DE1TXD,
DE1RXD,
OPTTXD,
OPTRXD,
// I2C
I2C_SCL,
I2C_DAT,
//Codec
AUD_XCK,
AUD_BCLK,
AUD_DACDAT,
AUD_DACLRCK,
AUD_ADCDAT,
AUD_ADCLRCK,
// 7 Segment Display
SEGMENT0_N,
SEGMENT1_N,
SEGMENT2_N,
SEGMENT3_N,
// LEDs
LEDG,
LEDR,
// CoCo Joystick
PADDLE_MCLK,
PADDLE_CLK,
P_SWITCH,
//SPI for SD Card
MOSI,
MISO,
SPI_CLK,
SPI_SS_N,
// Debug Test Points
//TEST_1,
//TEST_2,
//TEST_3,
//TEST_4,
// WiFi
WF_RXD,
WF_TXD,
RST,
//RTC I2C
CK_CLK,
CK_DAT,
// Buttons and Switches
SWITCH,
BUTTON_N
);

//Version 4 bits Major and 4 bits Minor
parameter Version_Hi = 8'h40;

// High 2 bits is Riser Type 00=Gary 01=Ed
// Next two bits is Memory type 00=Old 01=New
parameter Version_Lo = 8'h10;

//Memory Quantity
// CHOOSE ONLY ONE AT A TIME
//`define M5Meg			// Two 2Meg and DE1
`define M1Meg			// DE1

input				CLK50MHZ;
input				CLK24MHZ;
input				CLK24MHZ_2;
input				CLK27MHZ;
input				CLK27MHZ_2;
output			CLK3_57MHZ;
// DE1 RAM Common
//output [17:0]	RAM0_ADDRESS;	// 512kb SRAM
//reg	 [17:0]	RAM0_ADDRESS;
output [19:0]	RAM0_ADDRESS;		// 2MB SRAM.  Bit 19 unconnected on DE1, gives 1MB
reg	 [19:0]	RAM0_ADDRESS;
output			RAM0_RW_N;
reg				RAM0_RW_N;
// DE1 RAM bank 0
inout		[15:0]	RAM0_DATA;
reg		[15:0]	RAM0_DATA;
output				RAM0_CS_N;
wire					RAM_CS;						// DATA_IN Mux select
output				RAM0_BE0_N;
reg					RAM0_BE0_N;
output				RAM0_BE1_N;
reg					RAM0_BE1_N;
output				RAM0_OE_N;
wire					RAM0_BE0;
wire					RAM0_BE1;

// Analog Board RAM Common
output [19:0]	RAM1_ADDRESS;			// 2 MB SRAM
reg	 [19:0]	RAM1_ADDRESS;
output 			RAM1_ADDRESS9_1;
reg	 			RAM1_ADDRESS9_1;
output 			RAM1_ADDRESS10_1;
reg	 			RAM1_ADDRESS10_1;
output			RAM1_RW0_N;
reg				RAM1_RW0_N;
output			RAM1_RW1_N;
reg				RAM1_RW1_N;
// Ananlog SRAM bank 1
inout  [15:0]	RAM1_DATA;
reg	 [15:0]	RAM1_DATA;
output			RAM1_BE0_N;
reg				RAM1_BE0_N;
wire				RAM1_BE0;
output			RAM1_BE1_N;
reg				RAM1_BE1_N;
wire				RAM1_BE1;
output			RAM1_BE2_N;
reg				RAM1_BE2_N;
wire				RAM1_BE2;
output			RAM1_BE3_N;
reg				RAM1_BE3_N;
wire				RAM1_BE3;
output			RAM1_CS0_N;
wire				RAM1_CS0;
output			RAM1_CS1_N;
wire				RAM1_CS1;
output			RAM1_OE0_N;
output			RAM1_OE1_N;

//Flash ROM
output	[21:0]	FLASH_ADDRESS;
inout		[7:0]		FLASH_DATA;
output				FLASH_WE_N;
output				FLASH_RESET_N;
output				FLASH_CE_N;
output				FLASH_OE_N;

// SDRAM
output	[11:0]	SDRAM_ADDRESS;
output	[1:0]		SDRAM_BANK;
inout		[15:0]	SDRAM_DATA;
output				SDRAM_LDQM;
output				SDRAM_UDQM;
output				SDRAM_RAS_N;
output				SDRAM_CAS_N;
output				SDRAM_CKE;
output				SDRAM_CLK;
output				SDRAM_CS_N;
output				SDRAM_RW_N;

// VGA
output				RED3;
reg					RED3;
output				GREEN3;
reg					GREEN3;
output				BLUE3;
reg					BLUE3;
output				RED2;
reg					RED2;
output				GREEN2;
reg					GREEN2;
output				BLUE2;
reg					BLUE2;
output				RED1;
reg					RED1;
output				GREEN1;
reg					GREEN1;
output				BLUE1;
reg					BLUE1;
output				RED0;
reg					RED0;
output				GREEN0;
reg					GREEN0;
output				BLUE0;
reg					BLUE0;
output				H_SYNC;
reg					H_SYNC;
output				V_SYNC;
reg					V_SYNC;
wire					HBLANK;
wire					VBLANK;

// PS/2
input 				ps2_clk;
input					ps2_data;
//input					ms_clk;
//input					ms_data;

// Serial Ports
output				DE1TXD;
input					DE1RXD;
output				OPTTXD;
input					OPTRXD;
// I2C
output				I2C_SCL;			// Idiosyncrasy of DE1
inout					I2C_DAT;
//Codec
output				AUD_XCK;
input					AUD_BCLK;
output				AUD_DACDAT;
reg					AUD_DACDAT;
input					AUD_DACLRCK;
input					AUD_ADCDAT;
input					AUD_ADCLRCK;
// Display

output	[6:0]		SEGMENT0_N;
output	[6:0]		SEGMENT1_N;
output	[6:0]		SEGMENT2_N;
output	[6:0]		SEGMENT3_N;
wire		[6:0]		SEGMENT_N;
reg		[3:0]		DIGIT_N;
//`endif

// LEDs
output	[7:0]		LEDG;
//output	[9:0]		LEDR;
output	[7:0]		LEDR;			// LEDR9 and LEDR8 = A18 and A19 of 2MB SRAM

// CoCo Perpherial
output				PADDLE_MCLK;
input		[3:0]		PADDLE_CLK;
input		[3:0]		P_SWITCH;
//SPI
output				MOSI;
input					MISO;
output				SPI_CLK;
output				SPI_SS_N;
// Extra Buttons and Switches
input		[9:0]		SWITCH;			//  9 UART / DriveWire
											//		Off - DE1 Port is DriveWire and Analog Board is RS232 PAK
											//		on  - DE1 Port is RS232 PAK and Analog Board is DriveWire
											//  8 Serial Port Speed[1]
											//  7 Serial Port Speed[0]
											//    [1] [0]
											//		OFF OFF - 115200	// Swap UART / DriveWire
											//		OFF ON  - 230400
											//		ON  OFF - 460800	// Fastest for the DE1 Port
											//		ON  ON  - 921600
											//  6 SD Card Presence / Write Protect
											//		Off - Use card signals
											//		On  - Ignore Signals
											//  5 SG4 / SG6 mode select
											//		Off - SG4
											//		On  - SG6
											//  4 Cartridge Interrupt disabled except Disk
											//  3 Video Odd line black
											//		Off - Normal video
											//		On  - Odd lines black
											//  2 MPI [1]
											//  1 MPI [0]
											//    [1] [0]
											//		OFF OFF - Slot 1
											//		OFF ON  - Slot 2
											//		ON  OFF - Slot 3
											//		ON  ON  - Slot 4
											//  0 CPU Turbo Speed
											//		Off - Normal 1.78 MHz
											//		On  - 25 MHz

input [3:0]			BUTTON_N;		//  3 RESET
											//  2 SD Card Inserted (0=Inserted) wired to switche on the SD card
											//  1 SD Write Protect (1=Protected) wired to switche on the SD card
											//  0 Easter Egg

input					WF_RXD;
output				WF_TXD;
output				RST;

inout					CK_CLK;
inout					CK_DAT;
											
//output				TEST_1;			// Debug Test Points
//output				TEST_2;
//output				TEST_3;
//output				TEST_4;

wire					PH_2;
reg 					PH_2_RAW;
reg					RESET_N;
reg		[13:0]	RESET_SM;
reg					CPU_RESET;
wire					RESET;
wire					RESET_P;
wire		[15:0]	ADDRESS;
wire		[9:0]		BLOCK_ADDRESS;		// 5:0 for 512kb
wire					RW_N;
wire		[7:0]		DATA_IN;
wire		[7:0]		DATA_OUT;
wire					VMAX;
wire					VMA;
reg		[5:0]		CLK;

// Gime Regs
reg		[1:0]		ROM;
reg					RAM;
reg					ST_SCS;
reg					VEC_PAG_RAM;
reg					GIME_FIRQ;
reg					GIME_IRQ;
reg					MMU_EN;
reg					COCO1;
reg		[2:0]		V;
reg		[6:0]		VERT;
reg					RATE;
reg					TIMER_INS;
reg					MMU_TR;
reg					IRQ_TMR;
reg					IRQ_HBORD;
reg					IRQ_VBORD;
reg					IRQ_KEY;
reg					IRQ_CART;
reg					FIRQ_TMR;
reg					FIRQ_HBORD;
reg					FIRQ_VBORD;
reg					FIRQ_KEY;
reg					FIRQ_CART;
reg		[3:0]		TMR_MSB;
reg		[7:0]		TMR_LSB;
reg					TMR_ENABLE;
reg					TIMER_N;
reg		[1:0]		TIMER_STATE;
wire					TIMER_R;
reg		[15:0]	VIDEO_BUFFER;
reg					GRMODE;
reg					DESCEN;
reg					BLINK;
reg					MONO;
reg					HLPR;
reg		[2:0]		LPR;
reg		[1:0]		LPF;
reg		[3:0]		HRES;
reg		[1:0]		CRES;
reg		[3:0]		VERT_FIN_SCRL;
reg		[3:0]		SCRN_START_HSB;	// 4 extra bits for 4MB
reg		[7:0]		SCRN_START_MSB;
reg		[7:0]		SCRN_START_LSB;
reg		[6:0]		HOR_OFFSET;
reg					HVEN;
reg		[11:0]	PALETTE [16:0];
wire		[9:0]		COLOR;
reg		[9:0]		COLOR_BUF;
wire					H_SYNC_X;
wire					V_SYNC_X;
reg					HSYNC_INT;
reg					HSYNC_POL;
reg		[1:0]		SEL;
reg		[7:0]		KEY_COLUMN;
reg					VSYNC_INT;
reg					VSYNC_POL;
reg		[3:0]		VDG_CONTROL;
reg					CSS;
wire					BIT3;
reg					CART_INT;
reg					CART_POL;
reg					CD_INT;
reg					CD_POL;
reg					CAS_MTR;
reg					SOUND_EN;
wire		[21:0]	VIDEO_ADDRESS;		// 8MB   17:0 for 512kb
wire					ROM_RW;
wire					FLASH_CE_S;

wire					ENA_DSK;
wire					ENA_ORCC;
wire					ENA_DISK2;
wire					ENA_PAK;

wire					HDD_EN;
wire					HDD_EN_DATA;

reg		[1:0]		MPI_SCS;				// IO select
reg		[1:0]		MPI_CTS;				// ROM select
reg		[1:0]		W_PROT;
reg					SBS;
reg		[9:0]		SAM00;	// 8MB    5:0 for 512kb   
reg		[9:0]		SAM01;
reg		[9:0]		SAM02;
reg		[9:0]		SAM03;
reg		[9:0]		SAM04;
reg		[9:0]		SAM05;
reg		[9:0]		SAM06;
reg		[9:0]		SAM07;
reg		[9:0]		SAM10;
reg		[9:0]		SAM11;
reg		[9:0]		SAM12;
reg		[9:0]		SAM13;
reg		[9:0]		SAM14;
reg		[9:0]		SAM15;
reg		[9:0]		SAM16;
reg		[9:0]		SAM17;
reg		[1:0]		SAM_EXT;
wire		[72:0]	KEY;
wire					SHIFT_OVERRIDE;
wire					SHIFT;
wire		[7:0]		KEYBOARD_IN;
reg					DDR1;
reg					DDR2;
reg					DDR3;
reg					DDR4;
wire		[7:0]		DATA_REG1;
wire		[7:0]		DATA_REG2;
wire		[7:0]		DATA_REG3;
wire		[7:0]		DATA_REG4;
reg		[7:0]		DD_REG1;
reg		[7:0]		DD_REG2;
reg		[7:0]		DD_REG3;
reg		[7:0]		DD_REG4;
wire					ROM_SEL;
reg		[5:0]		DTOA_CODE;
reg		[5:0]		SOUND_DTOA;
wire		[7:0]		SOUND;
wire		[18:0]	DAC_LEFT;
wire		[18:0]	DAC_RIGHT;
wire		[7:0]		VU;
wire		[7:0]		VUM;
reg		[18:0]	LEFT;
reg		[18:0]	RIGHT;
reg		[18:0]	LEFT_BUF;
reg		[18:0]	RIGHT_BUF;
reg		[18:0]	LEFT_BUF2;
reg		[18:0]	RIGHT_BUF2;
reg		[7:0]		ORCH_LEFT;
reg		[7:0]		ORCH_RIGHT;
reg		[7:0]		ORCH_LEFT_EXT;
reg		[7:0]		ORCH_RIGHT_EXT;
reg		[7:0]		ORCH_LEFT_EXT_BUF;
reg		[7:0]		ORCH_RIGHT_EXT_BUF;
reg					DACLRCLK;
reg					ADCLRCLK;
reg		[5:0]		DAC_STATE;
wire 					H_FLAG;

reg		[1:0]		SWITCH_L;
wire					KEY_INT_RAW;
reg					HS_INT;
reg					H_SYNC_IRQ_N;
reg		[1:0]		HS_INT_SM;
reg					VS_INT;
reg					V_SYNC_IRQ_N;
reg		[1:0]		VS_INT_SM;
reg					CART1_INT;
reg		[1:0]		CART1_INT_SM;

reg					TMR_INT;
reg		[1:0]		TMR_INT_SM;
reg					HBORD_INT;
reg		[1:0]		HBORD_INT_SM;
reg					VBORD_INT;
reg		[1:0]		VBORD_INT_SM;
reg					KEY_INT;
reg		[1:0]		KEY_INT_SM;
reg					CAR_INT;
reg		[1:0]		CAR_INT_SM;

reg					TMR_FINT;
reg		[1:0]		TMR_FINT_SM;
reg					HBORD_FINT;
reg		[1:0]		HBORD_FINT_SM;
reg					VBORD_FINT;
reg		[1:0]		VBORD_FINT_SM;
reg					KEY_FINT;
reg		[1:0]		KEY_FINT_SM;
reg					CAR_FINT;
reg		[1:0]		CAR_FINT_SM;

wire					CPU_IRQ;
wire					CPU_FIRQ;
reg		[2:0]		DIV_7;
reg					DIV_14;
reg		[12:0]	TIMER;
wire					TMR_CLK;
wire					SER_IRQ;
wire					SER_IRQb;
reg					CART_IRQ;
reg		[4:0]		COM1_STATE;
reg		[12:0]	COM2_STATE;
reg					COM1_CLOCK_X;
reg					COM1_CLOCK;
reg		[2:0]		COM1_CLK;
wire		[7:0]		DATA_HDD;
wire					RS232_EN;
wire					RS232b_EN;
wire					RX_CLK2;
wire		[7:0]		DATA_RS232;
wire		[7:0]		DATA_RS232b;
reg		[2:0]		ROM_BANK;
reg		[1:0]		BANK_SIZE;
reg		[6:0]		BANK0;
reg		[6:0]		BANK1;
reg		[6:0]		BANK2;
reg		[6:0]		BANK3;
reg		[6:0]		BANK4;
reg		[6:0]		BANK5;
reg		[6:0]		BANK6;
reg		[6:0]		BANK7;
wire					SLOT3_HW;
wire					UART51_TXD;
wire					UART51_RXD;
wire					UART51_RTS;
wire					UART51_DTR;
wire					UART51b_RTS;
wire					UART51b_DTR;
wire					UART50_TXD;
wire					UART50_RXD;
wire					UART50_RTS;
// Clock
reg		[4:0]		CENT;
reg		[6:0]		YEAR;
reg		[3:0]		MNTH;
reg		[4:0]		DMTH;
reg		[2:0]		DWK;
reg		[4:0]		HOUR;
reg		[5:0]		MIN;
reg		[5:0]		SEC;
reg		[5:0]		CLICK;
reg					TICK0;
reg					TICK1;
reg					TICK2;
// Joystick
reg		[12:0]	JOY_CLK;
reg		[9:0]		PADDLE_ZERO_0;
reg		[9:0]		PADDLE_ZERO_1;
reg		[9:0]		PADDLE_ZERO_2;
reg		[9:0]		PADDLE_ZERO_3;
reg		[11:0]	PADDLE_VAL_0;
reg		[11:0]	PADDLE_VAL_1;
reg		[11:0]	PADDLE_VAL_2;
reg		[11:0]	PADDLE_VAL_3;
reg		[11:0]	PADDLE_LATCH_0;
reg		[11:0]	PADDLE_LATCH_1;
reg		[11:0]	PADDLE_LATCH_2;
reg		[11:0]	PADDLE_LATCH_3;
reg		[1:0]		PADDLE_STATE_0;
reg		[1:0]		PADDLE_STATE_1;
reg		[1:0]		PADDLE_STATE_2;
reg		[1:0]		PADDLE_STATE_3;
reg		[5:0]		JOY1_COUNT;
reg		[5:0]		JOY2_COUNT;
reg		[5:0]		JOY3_COUNT;
reg		[5:0]		JOY4_COUNT;
reg					JOY_TRIGGER;
wire					JSTICK;
wire					JOY1;
wire					JOY2;
wire					JOY3;
wire					JOY4;
reg					MOTOR;
reg					WRT_PREC;
reg					DENSITY;
reg					HALT_EN;
reg		[7:0]		COMMAND;
reg		[7:0]		SECTOR;
reg		[7:0]		DATA_EXT;
reg		[7:0]		STATUS;
reg					IRQ_02_N;
reg					IRQ_02_BUF0_N;
reg					IRQ_02_BUF1_N;
wire					IRQ_02_UART;
wire					IRQ_02_UART_2;
wire					NMI_09;
reg					HALT_BUF0;
reg					HALT_BUF1;
reg					HALT_BUF2;
reg					HALT_SIG_BUF0;
reg					HALT_SIG_BUF1;
reg		[6:0]		HALT_STATE;
wire					PH2_02;
wire		[15:0]	ADDRESS_02;
wire		[7:0]		CPU_BANK;
wire		[7:0]		DATA_OUT_02;
wire		[7:0]		DATA_IN_02;
wire		[7:0]		DATA_COM1;
reg		[8:0]		BUFF_ADD;
reg					ADDR_RESET_N;
reg					IMM_HALT_09;
wire					COM1_EN;
reg		[7:0]		TRACK_REG_R;
reg		[7:0]		TRACK_REG_W;
reg		[7:0]		TRACK_EXT_R;
reg		[7:0]		TRACK_EXT_W;
reg					NMI_09_EN;
wire					IRQ_09;
reg					IRQ_RESET;
reg					BUSY0;
reg					BUSY1;
reg		[7:0]		DRIVE_SEL_EXT;
wire		[3:0]		HEXX;
wire					HALT;
reg					FORCE_NMI_09_BUF0;
reg					FORCE_NMI_09_BUF1;
reg					ADDR_RST_BUFF0_N;
reg					ADDR_RST_BUFF1_N;
reg		[7:0]		TRACE;
reg					HALT_100_09;
reg					IRQ_09_EN;
reg					ADDR_100_BUF0;
reg					ADDR_100_BUF1;
reg					IRQ_09_BUF0;
reg					IRQ_09_BUF1;
reg					IRQ_09_BUF2;
reg					CMD_RST;
reg					WAIT_HALT;
reg					CMD_RST_BUF0;
reg					CMD_RST_BUF1;
wire					CPU_RESET_N;
wire					RW_02_N;
wire					DISKBUF_02;
wire		[7:0]		DISK_BUF_Q;
reg		[7:0]		DATA_REG;
wire					HALT_CODE;
wire					RAM02_00_EN;
wire		[7:0]		DATAO_02_HDD;
wire		[7:0]		DATAO_09_HDD;
reg		[7:0]		TRACK1;
reg		[7:0]		TRACK2;
reg		[7:0]		HEADS;
wire					RDFIFO_RDREQ;
wire					RDFIFO_WRREQ;
wire					WRFIFO_RDREQ;
wire					WRFIFO_WRREQ;
wire		[7:0]		RDFIFO_DATA;
wire		[7:0]		WRFIFO_DATA;
wire					RDFIFO_RDEMPTY;
wire					RDFIFO_WRFULL;
wire					WRFIFO_RDEMPTY;
wire					WRFIFO_WRFULL;
reg					BI_IRQ_EN;
wire					UART1_CLK;
reg 		[11:0]	MCLOCK;
wire					I2C_SCL_EN;
wire					I2C_DAT_EN;
reg		[7:0]		I2C_DEVICE;
reg		[7:0]		I2C_REG;
wire		[7:0]		I2C_DATA_IN;
reg		[7:0]		I2C_DATA_OUT;
wire		[5:0]		I2C_STATE;
wire					I2C_DONE;
reg		[1:0]		I2C_DONE_BUF;
wire					I2C_FAIL;
reg					I2C_START;
wire		[7:0]		SPI_DATA;
wire					SPI_EN;
wire					act_led_n;
wire					IRQ_SPI_N;
wire					SPI_TRACE;
reg		[7:0]		SPI_T;
wire					EF;
wire					VDA;
wire					MF;
wire					VPA;
wire					ML_N;
wire					XF;
wire					SYNC;
wire					VP_N;
reg					ODD_LINE;
wire					SPI_HALT;
reg	[22:0]		GART_WRITE;		// 8MB   18:0 for 512kb
reg	[22:0]		GART_READ;
reg	[1:0]			GART_INC;
reg	[16:0]		GART_CNT;
reg	[7:0]			GART_BUF;
reg	[7:0]			BI_TIMER;
reg					DBUF_BI_TO;
reg					DBUF_BI_TO1;
reg					BI_TO;
wire					BI_TO_RST;
reg					ANALOG;
reg	[1:0]			PDL_CLK;
wire					VDAC_EN;
wire	[15:0]		VDAC_OUT;
reg					WF_IRQ_EN;
reg	[5:0]			COM2_CLK;
reg					WF_CLOCK;
reg					WF_BAUD;
wire					COM2_EN;
wire					WF_WRFIFO_RDREQ;
wire					WF_RDFIFO_WRREQ;
wire					WF_RDFIFO_RDREQ;
wire		[7:0]		WF_RDFIFO_DATA;
wire					WF_RDFIFO_RDEMPTY;
wire					WF_RDFIFO_WRFULL;
wire					WF_WRFIFO_WRREQ;
wire		[7:0]		WF_WRFIFO_DATA;
wire					WF_WRFIFO_RDEMPTY;
wire					WF_WRFIFO_WRFULL;
wire	[7:0]			DATA_COM2;
wire					WF_RTS;
reg	[1:0]			CK_DONE_BUF;
wire					CK_CLK_EN;
wire					CK_DAT_EN;
reg	[7:0]			CK_DEVICE;
reg	[7:0]			CK_REG;
wire	[7:0]			CK_DATA_IN;
reg	[7:0]			CK_DATA_OUT;
wire					CK_DONE;
wire					CK_FAIL;
reg					CK_START;
wire	[5:0]			CK_STATE;
reg					SDRAM_READ;
wire	[15:0]		HDOUT;
reg	[15:0]		SDRAM_DIN;
reg	[15:0]		SDRAM_DOUT;
reg	[21:0]		SDRAM_ADDR;
reg	[2:0]			SDRAM_STATE;
reg					SDRAM_START;
reg	[1:0]			SDRAM_START_BUF;
reg					SDRAM_RD;
reg					SDRAM_WR;
wire					SDRAM_NEXT;
reg	[1:0]			SDRAM_NEXT_BUF;
wire					SDRAM_EOB;
wire					SDRAM_OB;
wire					SDRAM_RDP;
wire					SDRAM_DONE;
wire					SDRAM_RDD;
wire					SDRAM_STATUS;
wire	[15:0]		SDRAM_DATA_BUF;
wire					SDRAM_DATA_BUF_EN;




//assign LEDG = TRACE;														// Floppy Trace

assign LEDG[0]=  RAM0_BE0 | RAM0_BE1;
assign LEDG[1]=  RAM1_BE0 | RAM1_BE1;
assign LEDG[2]=  RAM1_BE2 | RAM1_BE3;
assign LEDG[3]= !FLASH_CE_S;
assign LEDG[4]= !FLASH_WE_N;
assign LEDG[5]=  (ADDRESS == 16'hFF84);			// SDRAM
assign LEDG[6]= !act_led_n;							// SD Card
assign LEDG[7]=  WF_RDFIFO_RDREQ;					// WiFi

//assign LEDG[0]=  (RAM_CS & RAM0_BE0);
//assign LEDG[1]=  (RAM_CS & RAM0_BE1);
//assign LEDG[2]=  !FLASH_CE_S;
//assign LEDG[3]= !(ROM_RW & FLASH_CE_S);
//assign LEDG[4]=  (ROM_RW & FLASH_CE_S);
//assign LEDG[3]= HDD_EN;
//assign LEDG[4]= HALT_BUF2;
//assign LEDG[5]=   RS232_EN;
//assign LEDG[6]=  !act_led_n;
//assign LEDG[7]=   KEY[55];

assign LEDR[0] = DRIVE_SEL_EXT[0] & MOTOR;
assign LEDR[1] = DRIVE_SEL_EXT[1] & MOTOR;
assign LEDR[2] = DRIVE_SEL_EXT[2] & MOTOR;
assign LEDR[3] = DRIVE_SEL_EXT[3] & MOTOR;
assign LEDR[4] = !UART50_TXD | !UART50_RXD;
assign LEDR[5]=   KEY[55];
assign LEDR[6] = !BUTTON_N[2] & (BUTTON_N[1] | SWITCH[6]);		// SD Card Write Protected when SD Card Inserted
assign LEDR[7] = !BUTTON_N[2];											// SD Card inserted

//Master clock divider chain
//	MCLOCK[0] = 50/2		= 25 MHz
//	MCLOCK[1] = 50/4		= 12.5 MHz
//	MCLOCK[2] = 50/8		= 6.25 MHz
//	MCLOCK[3] = 50/16		= 3.125 MHz
//	MCLOCK[4] = 50/32		= 1.5625 MHz
//	MCLOCK[5] = 50/64		= 781.25 KHz
//	MCLOCK[6] = 50/128		= 390.625 KHz
//	MCLOCK[7] = 50/256		= 195.125 KHz
//	MCLOCK[8] = 50/512		= 97.65625 KHz
//	MCLOCK[9] = 50/1024		= 48.828125 KHz
//	MCLOCK[10] = 50/2048	= 24.4140625 KHz
//	MCLOCK[11] = 50/4096	= 12.20703125 KHz

always @ (negedge CLK50MHZ)				//50 MHz
	MCLOCK <= MCLOCK + 1'b1;
assign RST = RESET_N;
assign SEGMENT0_N =	{7'b0100011};					//o
assign SEGMENT1_N =	{7'b1000110};					//C
assign SEGMENT2_N =	{7'b0100011};					//o
assign SEGMENT3_N =	{7'b1000110};					//C
/*
always @ (negedge V_SYNC)					// Anything > 200 HZ
case(DIGIT_N)
  4'b1110:	DIGIT_N <= 4'b1101;
  4'b1101:	DIGIT_N <= 4'b1011;
  4'b1011:	DIGIT_N <= 4'b0111;
  default:  DIGIT_N <= 4'b1110;
 endcase

always @ (negedge V_SYNC)
begin
	case (DIGIT_N)
	4'b1110:
		SEGMENT0_N <= SEGMENT_N;
	4'b1101:
		SEGMENT1_N <= SEGMENT_N;
	4'b1011:
		SEGMENT2_N <= SEGMENT_N;
	default:
		SEGMENT3_N <= SEGMENT_N;
	endcase
end

assign SEGMENT_N = 	(HEXX == 4'h0)	?	{7'b1000000}:				//0
							(HEXX == 4'h1)	?	{7'b1111001}:					//1
							(HEXX == 4'h2)	?	{7'b0100100}:					//2
							(HEXX == 4'h3)	?	{7'b0110000}:					//3
							(HEXX == 4'h4)	?	{7'b0011001}:					//4
							(HEXX == 4'h5)	?	{7'b0010010}:					//5
							(HEXX == 4'h6)	?	{7'b0000010}:					//6
							(HEXX == 4'h7)	?	{7'b1111000}:					//7
							(HEXX == 4'h8)	?	{7'b0000000}:					//8
							(HEXX == 4'h9)	?	{7'b0011000}:					//9
							(HEXX == 4'hA)	?	{7'b0001000}:					//A
							(HEXX == 4'hB)	?	{7'b0000011}:					//B
							(HEXX == 4'hC)	?	{7'b1000110}:					//C
							(HEXX == 4'hD)	?	{7'b0100001}:					//D
							(HEXX == 4'hE)	?	{7'b0000110}:					//E
													{7'b0001110};					//F

assign HEXX	=	({DIGIT_N} == 4'b1110)	?				VIDEO_ADDRESS[10:7]:
					({DIGIT_N} == 4'b1101)	?				VIDEO_ADDRESS[14:11]:
					({DIGIT_N} == 4'b1011)	?				VIDEO_ADDRESS[18:15]:
																	{1'b0,VIDEO_ADDRESS[21:19]};

*/
/*****************************************************************************
* RAM signals
******************************************************************************/
`ifdef M5Meg
assign	RAM0_BE0 =	((ADDRESS == 16'hFF73)&&  RW_N && ({GART_READ[22:21], GART_READ[0]}  == 3'b100))	?	1'b1:
							((ADDRESS == 16'hFF73)&& !RW_N && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b100))	?	1'b1:
							( !VMA && !GART_CNT[0] 			 && ({GART_READ[22:21], GART_READ[0]}  == 3'b100))	?	1'b1:
							( !VMA &&  GART_CNT[0]			 && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b100))	?	1'b1:
							(  VMA &&  RAM_CS					 && {BLOCK_ADDRESS[9:8],ADDRESS[0]}  ==  3'b100)	?	1'b1:
																																			1'b0;

assign	RAM0_BE1 =	((ADDRESS == 16'hFF73)&&  RW_N && ({GART_READ[22:21], GART_READ[0]}  == 3'b101))	?	1'b1:
							((ADDRESS == 16'hFF73)&& !RW_N && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b101))	?	1'b1:
							( !VMA && !GART_CNT[0] 			 && ({GART_READ[22:21], GART_READ[0]}  == 3'b101))	?	1'b1:
							( !VMA &&  GART_CNT[0]			 && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b101))	?	1'b1:
							(  VMA &&  RAM_CS					 && {BLOCK_ADDRESS[9:8],ADDRESS[0]}  ==  3'b101)	?	1'b1:
																																			1'b0;

assign	RAM1_BE0 =	((ADDRESS == 16'hFF73)&&  RW_N && ({GART_READ[22:21], GART_READ[0]}  == 3'b000))	?	1'b1:
							((ADDRESS == 16'hFF73)&& !RW_N && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b000))	?	1'b1:
							( !VMA && !GART_CNT[0] 			 && ({GART_READ[22:21], GART_READ[0]}  == 3'b000))	?	1'b1:
							( !VMA &&  GART_CNT[0]			 && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b000))	?	1'b1:
							(  VMA &&  RAM_CS					 && {BLOCK_ADDRESS[9:8],ADDRESS[0]}  ==  3'b000)	?	1'b1:
																																			1'b0;

assign	RAM1_BE1 =	((ADDRESS == 16'hFF73)&&  RW_N && ({GART_READ[22:21], GART_READ[0]}  == 3'b001))	?	1'b1:
							((ADDRESS == 16'hFF73)&& !RW_N && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b001))	?	1'b1:
							( !VMA && !GART_CNT[0] 			 && ({GART_READ[22:21], GART_READ[0]}  == 3'b001))	?	1'b1:
							( !VMA &&  GART_CNT[0]			 && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b001))	?	1'b1:
							(  VMA &&  RAM_CS					 && {BLOCK_ADDRESS[9:8],ADDRESS[0]}  ==  3'b001)	?	1'b1:
																																			1'b0;

assign	RAM1_BE2 =	((ADDRESS == 16'hFF73)&&  RW_N && ({GART_READ[22:21], GART_READ[0]}  == 3'b010))	?	1'b1:
							((ADDRESS == 16'hFF73)&& !RW_N && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b010))	?	1'b1:
							( !VMA && !GART_CNT[0] 			 && ({GART_READ[22:21], GART_READ[0]}  == 3'b010))	?	1'b1:
							( !VMA &&  GART_CNT[0]			 && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b010))	?	1'b1:
							(  VMA &&  RAM_CS					 && {BLOCK_ADDRESS[9:8],ADDRESS[0]}  ==  3'b010)	?	1'b1:
																																			1'b0;

assign	RAM1_BE3 =	((ADDRESS == 16'hFF73)&&  RW_N && ({GART_READ[22:21], GART_READ[0]}  == 3'b011))	?	1'b1:
							((ADDRESS == 16'hFF73)&& !RW_N && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b011))	?	1'b1:
							( !VMA && !GART_CNT[0] 			 && ({GART_READ[22:21], GART_READ[0]}  == 3'b011))	?	1'b1:
							( !VMA &&  GART_CNT[0]			 && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b011))	?	1'b1:
							(  VMA &&  RAM_CS					 && {BLOCK_ADDRESS[9:8],ADDRESS[0]}  ==  3'b011)	?	1'b1:
																																			1'b0;
`endif

`ifdef M1Meg
assign	RAM0_BE0 =	((ADDRESS == 16'hFF73)&&  RW_N && ({GART_READ[22:21], GART_READ[0]}  == 3'b000))	?	1'b1:
							((ADDRESS == 16'hFF73)&& !RW_N && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b000))	?	1'b1:
							( !VMA && !GART_CNT[0] 			 && ({GART_READ[22:21], GART_READ[0]}  == 3'b000))	?	1'b1:
							( !VMA &&  GART_CNT[0]			 && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b000))	?	1'b1:
							(  VMA &&  RAM_CS					 && ({BLOCK_ADDRESS[9:8],ADDRESS[0]}  ==  3'b000))	?	1'b1:
																																			1'b0;

assign	RAM0_BE1 =	((ADDRESS == 16'hFF73)&&  RW_N && ({GART_READ[22:21], GART_READ[0]}  == 3'b001))	?	1'b1:
							((ADDRESS == 16'hFF73)&& !RW_N && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b001))	?	1'b1:
							( !VMA && !GART_CNT[0] 			 && ({GART_READ[22:21], GART_READ[0]}  == 3'b001))	?	1'b1:
							( !VMA &&  GART_CNT[0]			 && ({GART_WRITE[22:21],GART_WRITE[0]} == 3'b001))	?	1'b1:
							(  VMA &&  RAM_CS					 && ({BLOCK_ADDRESS[9:8],ADDRESS[0]}  ==  3'b001))	?	1'b1:
																																			1'b0;

assign	RAM1_BE0 =	1'b0;
assign	RAM1_BE1 =	1'b0;
assign	RAM1_BE2	=	1'b0;
assign	RAM1_BE3	=	1'b0;
`endif

assign	BLOCK_ADDRESS =	({MMU_EN, MMU_TR, ADDRESS[15:13]} ==  5'b10000)					?	SAM00:		// 10 000X	0000-1FFF
									({MMU_EN, MMU_TR, ADDRESS[15:13]} ==  5'b10001)					?	SAM01:		// 10 001X	2000-3FFF
									({MMU_EN, MMU_TR, ADDRESS[15:13]} ==  5'b10010)					?	SAM02:		// 10 010X	4000-5FFF
									({MMU_EN, MMU_TR, ADDRESS[15:13]} ==  5'b10011)					?	SAM03:		// 10 011X	6000-7FFF
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:13]} == 6'b010100)		?	SAM04:		//010 100X	8000-9FFF
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:13]} == 6'b010101)		?	SAM05:		//010 101X	A000-BFFF
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:13]} == 6'b010110)		?	SAM06:		//010 110X	C000-DFFF
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:12]} == 7'b0101110)	?	SAM07:		//010 1110 X		E000-EFFF
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:11]} == 8'b01011110)	?	SAM07:		//010 1111 0X		F000-F7FF
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:10]} == 9'b010111110)	?	SAM07:		//010 1111 10X		F800-FBFF
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:9]} == 10'b0101111110)?	SAM07:		//010 1111 110X	FC00-FDFF
							({VEC_PAG_RAM, MMU_EN, MMU_TR, ADDRESS[15:8]} == 11'b01011111110)	?	SAM07:		//010 1111 1110 X	FE00-FEFF Vector page as RAM
									({MMU_EN, MMU_TR, ADDRESS[15:13]} ==  5'b11000)					?	SAM10:		// 11 000X
									({MMU_EN, MMU_TR, ADDRESS[15:13]} ==  5'b11001)					?	SAM11:		// 11 001X
									({MMU_EN, MMU_TR, ADDRESS[15:13]} ==  5'b11010)					?	SAM12:		// 11 010X
									({MMU_EN, MMU_TR, ADDRESS[15:13]} ==  5'b11011)					?	SAM13:		//011 011X
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:13]} == 6'b011100)		?	SAM14:		//011 100X
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:13]} == 6'b011101)		?	SAM15:		//011 101X
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:13]} == 6'b011110)		?	SAM16:		//011 110X
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:12]} == 7'b0111110)	?	SAM17:		//011 1110 X		E000-EFFF
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:11]} == 8'b01111110)	?	SAM17:		//011 1111 0X		F000-F7FF
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:10]} == 9'b011111110)	?	SAM17:		//011 1111 10X		F800-FBFF
									({ROM_SEL, MMU_EN, MMU_TR, ADDRESS[15:9]} == 10'b0111111110)?	SAM17:		//011 1111 110X	FC00-FDFF
							({VEC_PAG_RAM, MMU_EN, MMU_TR, ADDRESS[15:8]} == 11'b01111111110)	?	SAM17:		//011 1111 1110 X	FE00-FEFF Vector page as RAM
																														{7'b0000111,ADDRESS[15:13]};

assign RAM0_CS_N = 1'b0;																						// Actual RAM CS is always enabled
assign RAM1_CS0_N = 1'b0;																						// Actual RAM CS is always enabled
assign RAM1_CS1_N = 1'b0;																						// Actual RAM CS is always enabled
assign RAM0_OE_N = 1'b0;
assign RAM1_OE0_N = 1'b0;
assign RAM1_OE1_N = 1'b0;
assign RAM_CS =			(ROM_SEL)												?	1'b0:		// Any slot
								({RAM, ADDRESS[15:14]} == 3'b010)				?	1'b0:		// ROM (8000-BFFF)
								({RAM, ADDRESS[15:13]} == 4'b0110)				?	1'b0:		// ROM (C000-DFFF)
								({RAM, ADDRESS[15:12]} == 5'b01110)				?	1'b0:		// ROM (E000-EFFF)
								({RAM, ADDRESS[15:11]} == 6'b011110)			?	1'b0:		// ROM (F000-F8FF)
								({RAM, ADDRESS[15:10]} == 7'b0111110)			?	1'b0:		// ROM (F800-FBFF)
								({RAM, ADDRESS[15:9]}  == 8'b01111110)			?	1'b0:		// ROM (FC00-FDFF)
//								({BLOCK_ADDRESS[9:8]} != 2'b10)					?	1'b0:		// 0 - 4M
								(ADDRESS[15:0]== 18'h2FF73)						?	1'b1:		// GART
//								(!VMA & (GART_CNT != 17'h00000))					?	1'b1:		// Chip Select is not needed for the memcopy
								({ADDRESS[15:8]}== 8'hFF)							?	1'b0:		// Hardware (FF00-FFFF)
																								1'b1;

/*
assign RAM1_CS0 =			(ROM_SEL)															?	1'b0:		// Any slot
								({RAM, ADDRESS[15:14]} == 3'b010)							?	1'b0:		// ROM (8000-BFFF)
								({RAM, ADDRESS[15:13]} == 4'b0110)							?	1'b0:		// ROM (C000-DFFF)
								({RAM, ADDRESS[15:12]} == 5'b01110)							?	1'b0:		// ROM (E000-EFFF)
								({RAM, ADDRESS[15:11]} == 6'b011110)						?	1'b0:		// ROM (F000-F8FF)
								({RAM, ADDRESS[15:10]} == 7'b0111110)						?	1'b0:		// ROM (F800-FBFF)
								({RAM, ADDRESS[15:9]}  == 8'b01111110)						?	1'b0:		// ROM (FC00-FDFF)
								({BLOCK_ADDRESS[9:8]} != 2'b00)								?	1'b0:		// 2M - 8M
								({BLOCK_ADDRESS[9:8],ADDRESS[15:0]}== 18'h0FF73)		?	1'b1:		// GART
								({ADDRESS[15:8]}== 8'hFF)										?	1'b0:		// Hardware (FF00-FFFF)
																											1'b1;		// 0 - 2M

assign RAM1_CS1 =			(ROM_SEL)															?	1'b0:		// Any slot
								({RAM, ADDRESS[15:14]} == 3'b010)							?	1'b0:		// ROM (8000-BFFF)
								({RAM, ADDRESS[15:13]} == 4'b0110)							?	1'b0:		// ROM (C000-DFFF)
								({RAM, ADDRESS[15:12]} == 5'b01110)							?	1'b0:		// ROM (E000-EFFF)
								({RAM, ADDRESS[15:11]} == 6'b011110)						?	1'b0:		// ROM (F000-F8FF)
								({RAM, ADDRESS[15:10]} == 7'b0111110)						?	1'b0:		// ROM (F800-FBFF)
								({RAM, ADDRESS[15:9]}  == 8'b01111110)						?	1'b0:		// ROM (FC00-FDFF)
								({BLOCK_ADDRESS[9:8]} != 2'b01)								?	1'b0:		// 0 - 2M and 4M - 8M
								({BLOCK_ADDRESS[9:8],ADDRESS[15:0]}== 18'h1FF73)		?	1'b1:		// GART
								({ADDRESS[15:8]}== 8'hFF)										?	1'b0:		// Hardware (FF00-FFFF)
																											1'b1;		// 2M - 4M
*/
/*****************************************************************************
* ROM signals
******************************************************************************/
// ROM_SEL is 1 when the system is accessing any cartridge "ROM" meaning the
// 4 slots of the MPI, this is:
//		Slot 1 	Orchestra-90C
//		Slot 2	Alternate Disk Controller ROM
//		Slot 3	Cart slot
//		Slot 4	Disk Controller ROM
assign	ROM_SEL =( RAM								== 1'b1)		?	1'b0:	// All RAM Mode
						( ROM 							== 2'b10)	?	1'b0:	// All Internal
						({ROM[1], ADDRESS[15:14]}	== 3'b010)	?	1'b0: // Lower (Internal) 16 Internal+16 external
						(			 ADDRESS[15]		== 1'b0)		?	1'b0:	// Lower 32K
						(			 ADDRESS[15:8]		== 8'hFE)	?	1'b0:	// Vector space
						(			 ADDRESS[15:8]		== 8'hFF)	?	1'b0:	// Hardware space
																				1'b1;

//ROM
//00		16 Internal + 16 External
//01		16 Internal + 16 External
//10		32 Internal
//11		32 External

assign	FLASH_ADDRESS =	ENA_DSK			?	{9'b000000100, ADDRESS[12:0]}:	//8K Disk BASIC 8K Slot 4
									ENA_DISK2		?	{7'b1111111,   ADDRESS[14:0]}:	//ROM Anternative Disk Controller
									ENA_ORCC			?	{9'b000000101, ADDRESS[12:0]}:	//8K Orchestra 8K 90CC Slot 1
// Slot 3 ROMPak
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b100000)	?	{BANK0,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b110000)	?	{BANK0,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b101000)	?	{BANK0,1'b0,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b111000)	?	{BANK0,1'b1,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b100001)	?	{BANK1,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b110001)	?	{BANK1,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b101001)	?	{BANK1,1'b0,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b111001)	?	{BANK1,1'b1,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b100010)	?	{BANK2,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b110010)	?	{BANK2,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b101010)	?	{BANK2,1'b0,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b111010)	?	{BANK2,1'b1,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b100011)	?	{BANK3,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b110011)	?	{BANK3,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b101011)	?	{BANK3,1'b0,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b111011)	?	{BANK3,1'b1,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b100100)	?	{BANK4,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b110100)	?	{BANK4,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b101100)	?	{BANK4,1'b0,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b111100)	?	{BANK4,1'b1,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b100101)	?	{BANK5,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b110101)	?	{BANK5,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b101101)	?	{BANK5,1'b0,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b111101)	?	{BANK5,1'b1,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b100110)	?	{BANK6,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b110110)	?	{BANK6,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b101110)	?	{BANK6,1'b0,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b111110)	?	{BANK6,1'b1,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b100111)	?	{BANK7,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b110111)	?	{BANK7,     ADDRESS[14:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b101111)	?	{BANK7,1'b0,ADDRESS[13:0]}:
({ENA_PAK,BANK_SIZE,ROM_BANK}== 6'b111111)	?	{BANK7,1'b1,ADDRESS[13:0]}:
																{7'b0000000, ADDRESS[14:0]};

assign FLASH_WE_N = !(ROM_RW & FLASH_CE_S);
assign FLASH_CE_N = !FLASH_CE_S;
assign FLASH_OE_N =  (ROM_RW & FLASH_CE_S);

assign FLASH_CE_S =	({RAM, ROM[1], ADDRESS[15:14]} ==  4'b0010)				?	1'b1:		// Internal 32K ROM 8000-BFFF
							({RAM, ROM,    ADDRESS[15:13]} ==  6'b010110)			?	1'b1:		// Internal 32K ROM C000-DFFF
							({RAM, ROM,    ADDRESS[15:12]} ==  7'b0101110)			?	1'b1:		// Internal 32K ROM E000-EFFF
							({RAM, ROM,    ADDRESS[15:11]} ==  8'b01011110)			?	1'b1:		// Internal 32K ROM F000-F7FF
							({RAM, ROM,    ADDRESS[15:14]} ==  5'b01010)				?	1'b1:		// Internal 16K ROM 8000-B7FF
							({RAM, ROM,    ADDRESS[15:10]} ==  9'b010111110)		?	1'b1:		// Internal ROM F800-F8FF
							({RAM, ROM,    ADDRESS[15:8]}  == 11'b01011111100)		?	1'b1:		// Internal ROM FC00-FCFF
							({RAM, ROM,    ADDRESS[15:8]}  == 11'b01011111101)		?	1'b1:		// Internal ROM FD00-FDFF
							ENA_DSK																?	1'b1:
							ENA_PAK																?	1'b1:
							ENA_DISK2															?	1'b1:
							ENA_ORCC																?	1'b1:
																										1'b0;

assign FLASH_DATA = (!FLASH_WE_N)	?	DATA_OUT:
													8'bZZZZZZZZ;

assign	FLASH_RESET_N = RESET_N;
/*
assign	ENA_DSK =	({ROM_SEL, MPI_CTS, ADDRESS[15:13]} == 6'b111110)		?	1'b1:	// Disk C000-DFFF Slot 4
																										1'b0;
assign	ENA_ORCC =	({ROM_SEL, MPI_CTS, ADDRESS[15:13]} == 6'b100110)		?	1'b1:	// Orchestra-90CC C000-DFFF Slot 1
																										1'b0;
assign	ENA_DISK2 =	({ROM_SEL, MPI_CTS, ADDRESS[15]} == 4'b0011)				?	1'b1:	// Alternative Disk controller ROM up to 32K
																										1'b0;
assign	ENA_PAK =	({ROM_SEL, MPI_CTS, ADDRESS[15]} == 4'b1101)				?	1'b1:	// ROM SLOT 3
																										1'b0;
*/
assign	ENA_ORCC =	({ROM_SEL, MPI_CTS} == 3'b100)	?	1'b1:	// Orchestra-90CC C000-DFFF Slot 1
																			1'b0;
assign	ENA_DISK2 =	({ROM_SEL, MPI_CTS} == 3'b101)	?	1'b1:	// Alternative Disk controller ROM up to 32K
																			1'b0;
assign	ENA_PAK =	({ROM_SEL, MPI_CTS} == 3'b110)	?	1'b1:	// ROM SLOT 3
																			1'b0;
assign	ENA_DSK =	({ROM_SEL, MPI_CTS} == 3'b111)	?	1'b1:	// Disk C000-DFFF Slot 4
																			1'b0;
assign	HDD_EN = ({MPI_SCS[0], ADDRESS[15:4]}	 == 13'b1111111110100)		?	1'b1:	// FF40-FF4F with MPI switch = 2 or 4
																										1'b0;

assign	RS232_EN = (ADDRESS[15:2] == 14'b11111111011010)						?	1'b1:	//FF68-FF6B
																										1'b0;

assign	SPI_EN = 			(ADDRESS[15:1]  == 15'b111111110110010);							// SPI FF64-FF65

assign	SLOT3_HW = ({MPI_SCS, ADDRESS[15:5]} == 13'b1011111111010)			?	1'b1:		 // FF40-FF5F
																										1'b0;

assign	VDAC_EN = ({RW_N,ADDRESS[15:0]} == 17'H0FF7E)							?	1'b1:		 // FF7E
																										1'b0;

always @(negedge PH_2 or negedge RESET_N)
begin
	if(!RESET_N)
	begin
		ROM_BANK <= 3'b000;
	end
	else
	begin
		if({SLOT3_HW, RW_N} == 2'b10)
			case (ADDRESS[4:0])
			5'h00:
			begin
				ROM_BANK <= DATA_OUT[2:0];
			end
			5'h02:
			begin
				BANK0 <= DATA_OUT[6:0];
			end
			5'h03:
			begin
				BANK_SIZE <= DATA_OUT[1:0];
			end
			5'h04:
			begin
				BANK1 <= DATA_OUT[6:0];
			end
			5'h05:
			begin
				BANK2 <= DATA_OUT[6:0];
			end
			5'h06:
			begin
				BANK3 <= DATA_OUT[6:0];
			end
			5'h07:
			begin
				BANK4 <= DATA_OUT[6:0];
			end
			5'h08:
			begin
				BANK5 <= DATA_OUT[6:0];
			end
			5'h09:
			begin
				BANK6 <= DATA_OUT[6:0];
			end
			5'h0A:
			begin
				BANK7 <= DATA_OUT[6:0];
			end
			endcase
	end
end
/*
$FF40 - This is the bank latch. The same latch that is used by the Super Program Paks to bank 16K of the Pak ROM
at a time. The initial design simply used 32K banks - this would allow the Super Program Paks to function, but
wastes 16K per Bank. This was done so the banks could house any of the 32K CoCo 3 Program PAKs as well. This latch
is set to $00 on reset or power up (same as the super program paks).

$FF41 - the CTS* WRITE data latch. This was incorporated because the CTS* line is read only. I could have just
derived a new CTS* that is active on both reads and writes, however, some PAKs utilize a copy protection scheme
whereas they write to the PAK area. As long as the PAK was in ROM, nothing happened, but if trying to run from a
R/W* RAMPAK, or from disk (wheras the CoCo is placed in the allram mode and the PAK transferred there and executed),
then the PAK code would be corrupted and a crash would occur. This behavior could be patched out of the PAK but I
wanted to be able to execute the PAK code verbatim. Thus this latch at $FF41. A byte of data is written to $FF41.
It is latched and a flip-flop is triggered (this flip-flop starts up un-triggered - either at power on or reset).
Once the flip-flop is triggered, it indicates a valid byte has been stored at $FF41 and then any READ of the CTS*
area will WRITE the byte from $FF41 into the SRAM at the memory location that was READ, the flip-flop is also
reset by this action. This allows writing to the CTS* area while still providing the Read Only protection offered
by the CTS* signal.
$FF42 - BANK 0 latch - this was incorporated because Aaron wanted to be able to start up with his operating code in
bank $00, however, the super program PAKs must start at bank $00. So, whatever is written into this latch will
be the bank that is accessed as BANK 0. This is reset to $00 only at power on (Not reset). So, whatever is written
here will be the bank accessed as bank 00 from that point forward, until it is changed again. Reset will not change it.
$FF43 - Bank Size latch. Only two bits used.:
             Bit 0 = 0 = 32K BANK SIZE, =1=16K Banks Size
             Bit 1 = 0 = Use lower 16K of each 32K bank
             Bit 1 = 1 = Use upper 16K of each 32K bank
Bit 1 is only effective if bank size is set to 16K by bit 0. This register is set to $00 at power on or reset,
and was added to reduce wasted memory. Under proper program control this allows two 16K or less program paks to
exist in each 32K bank.

$FF44-$FF4A = bank 1 through bank 7 latches. The largest super program pak that I am aware of was RoboCop,
consuming 8 banks of 16K for 128K total. These work just like the latch at $FF42 EXCEPT they affect banks 1-7.
They are also set to $01-$07 (respectively) on power up (but not reset). This allows a Super Program Pak to reside
in any banks in any order, by simply writing the proper data into these latches.
*/

// If W_PROT[1] = 1 then ROM_RW is 0, else ROM_RW = !RW_N
assign	ROM_RW = !(W_PROT[1] | RW_N);

assign	DATA_IN =								RAM0_BE0		?	RAM0_DATA[7:0]:
														RAM0_BE1		?	RAM0_DATA[15:8]:
														RAM1_BE0		?	RAM1_DATA[7:0]:
														RAM1_BE1		?	RAM1_DATA[15:8]:
														RAM1_BE2		?	RAM1_DATA[7:0]:
														RAM1_BE3		?	RAM1_DATA[15:8]:
														FLASH_CE_S	?	FLASH_DATA:
														HDD_EN		?	DATA_HDD:
														RS232_EN		?	DATA_RS232:
														SLOT3_HW		?	{5'b00000, ROM_BANK}:
												WF_RDFIFO_RDREQ	?	WF_RDFIFO_DATA:
										(ADDRESS == 16'hFF6C)	?	{(!WF_RDFIFO_RDEMPTY & WF_IRQ_EN),
																			5'b00000,
																			!WF_RDFIFO_RDEMPTY,							// 1 = data available
																			WF_WRFIFO_WRFULL}:							// 1 = Write FIFO Full
														SPI_EN		?	SPI_DATA:
// FF00, FF04, FF08, FF0C, FF10, FF14, FF18, FF1C
({ADDRESS[15:5], ADDRESS[1:0]} == 13'b1111111100000)	?	DATA_REG1:
// FF01, FF05, FF09, FF0D, FF11, FF15, FF19, FF1D
({ADDRESS[15:5], ADDRESS[1:0]} == 13'b1111111100001)	?	{!HS_INT, 3'b011, SEL[0], DDR1, HSYNC_POL, HSYNC_INT}:
// FF02, FF06, FF0A, FF0E, FF12, FF16, FF1A, FF1E
({ADDRESS[15:5], ADDRESS[1:0]} == 13'b1111111100010)	?	DATA_REG2:
// FF03, FF07, FF0B, FF0F, FF13, FF17, FF1B, FF1F
({ADDRESS[15:5], ADDRESS[1:0]} == 16'b1111111100011)	?	{!VS_INT, 3'b011, SEL[1], DDR2, VSYNC_POL, VSYNC_INT}:
// FF20, FF24, FF28, FF2C, FF30, FF34, FF38, FF3C
({ADDRESS[15:5], ADDRESS[1:0]} == 16'b1111111100100)	?	DATA_REG3:
// FF21, FF25, FF29, FF2D, FF31, FF35, FF39, FF3D
({ADDRESS[15:5], ADDRESS[1:0]} == 16'b1111111100101)	?	{4'b0011, CAS_MTR, DDR3, CD_POL, CD_INT}:
// FF22, FF26, FF2A, FF2E, FF32, FF36, FF3A, FF3E
({ADDRESS[15:5], ADDRESS[1:0]} == 16'b1111111100110)	?	DATA_REG4:
// FF23, FF27, FF2B, FF2F, FF33, FF37, FF3B, FF3F
({ADDRESS[15:5], ADDRESS[1:0]} == 16'b1111111100111)	?	{!CART1_INT, 3'b011, SOUND_EN, DDR4, CART_POL, CART_INT}:
// HiRes Joystick
									(ADDRESS == 16'hFF60)		?	PADDLE_LATCH_0[9:2]:
									(ADDRESS == 16'hFF61)		?	{PADDLE_LATCH_0[1:0],6'b000000}:
									(ADDRESS == 16'hFF62)		?	PADDLE_LATCH_1[9:2]:
									(ADDRESS == 16'hFF63)		?	{PADDLE_LATCH_1[1:0],6'b000000}:
									(ADDRESS == 16'hFF64)		?	PADDLE_LATCH_2[9:2]:
									(ADDRESS == 16'hFF65)		?	{PADDLE_LATCH_2[1:0],6'b000000}:
									(ADDRESS == 16'hFF66)		?	PADDLE_LATCH_3[9:2]:
									(ADDRESS == 16'hFF67)		?	{PADDLE_LATCH_3[1:0],6'b000000}:

									(ADDRESS == 16'hFF70)		?	{1'b0, GART_WRITE[22:16]}:		// 2MB
									(ADDRESS == 16'hFF71)		?	{       GART_WRITE[15:8]}:
									(ADDRESS == 16'hFF72)		?	{       GART_WRITE[7:0]}:
									(ADDRESS == 16'hFF74)		?	{1'b0, GART_READ[22:16]}:
									(ADDRESS == 16'hFF75)		?	{       GART_READ[15:8]}:
									(ADDRESS == 16'hFF76)		?	{       GART_READ[7:0]}:
									(ADDRESS == 16'hFF77)		?	{(GART_CNT == 17'h00000),5'b00000, GART_INC[1:0]}:
									(ADDRESS == 16'hFF7F)		?	{2'b11, MPI_CTS, W_PROT, MPI_SCS}:
									(ADDRESS == 16'hFF80)		?	{CK_DONE_BUF[1],
																						CK_FAIL,
																						CK_STATE}:
									(ADDRESS == 16'hFF81)		?	CK_DATA_IN:

									(ADDRESS == 16'hFF84)		?	{7'b0000000, SDRAM_READ}:
									(ADDRESS == 16'hFF85)		?	SDRAM_DOUT[7:0]:
									(ADDRESS == 16'hFF86)		?	SDRAM_DOUT[15:8]:
									(ADDRESS == 16'hFF87)		?	SDRAM_ADDR[14:7]:
									(ADDRESS == 16'hFF88)		?	SDRAM_ADDR[21:15]:

									(ADDRESS == 16'hFF90)		?	{COCO1, MMU_EN, GIME_IRQ, GIME_FIRQ, VEC_PAG_RAM, ST_SCS, ROM}:
									(ADDRESS == 16'hFF91)		?	{2'b00, TIMER_INS, 4'b0000, MMU_TR}:
									(ADDRESS == 16'hFF92)		?	{2'b00, !TMR_INT,  !HBORD_INT,  !VBORD_INT,  1'b0, !KEY_INT,  !CAR_INT}:
									(ADDRESS == 16'hFF93)		?	{2'b00, !TMR_FINT, !HBORD_FINT, !VBORD_FINT, 1'b0, !KEY_FINT, !CAR_FINT}:
									(ADDRESS == 16'hFF94)		?	{4'h0,TMR_MSB}:
									(ADDRESS == 16'hFF95)		?	TMR_LSB:
//									(ADDRESS == 16'hFF98)		?	{GRMODE, HRES[3], DESCEN, MONO, 1'b0, LPR}:
//									(ADDRESS == 16'hFF99)		?	{HLPR, LPF, HRES[2:0], CRES}:
//									(ADDRESS == 16'hFF9A)		?	{2'b00, PALETTE[16][5:0]}:
//									(ADDRESS == 16'hFF9B)		?	{2'b00, SAM_EXT, SCRN_START_HSB}:	// 4 extra bits for 8MB. Real hardware can't read back!!
//									(ADDRESS == 16'hFF9C)		?	{4'h0,VERT_FIN_SCRL}:
//									(ADDRESS == 16'hFF9D)		?	SCRN_START_MSB:
//									(ADDRESS == 16'hFF9E)		?	SCRN_START_LSB:
//									(ADDRESS == 16'hFF9F)		?	{HVEN,HOR_OFFSET}:
									(ADDRESS == 16'hFFA0)		?	SAM00[7:0]:
									(ADDRESS == 16'hFFA1)		?	SAM01[7:0]:
									(ADDRESS == 16'hFFA2)		?	SAM02[7:0]:
									(ADDRESS == 16'hFFA3)		?	SAM03[7:0]:
									(ADDRESS == 16'hFFA4)		?	SAM04[7:0]:
									(ADDRESS == 16'hFFA5)		?	SAM05[7:0]:
									(ADDRESS == 16'hFFA6)		?	SAM06[7:0]:
									(ADDRESS == 16'hFFA7)		?	SAM07[7:0]:
									(ADDRESS == 16'hFFA8)		?	SAM10[7:0]:
									(ADDRESS == 16'hFFA9)		?	SAM11[7:0]:
									(ADDRESS == 16'hFFAA)		?	SAM12[7:0]:
									(ADDRESS == 16'hFFAB)		?	SAM13[7:0]:
									(ADDRESS == 16'hFFAC)		?	SAM14[7:0]:
									(ADDRESS == 16'hFFAD)		?	SAM15[7:0]:
									(ADDRESS == 16'hFFAE)		?	SAM16[7:0]:
									(ADDRESS == 16'hFFAF)		?	SAM17[7:0]:
									(ADDRESS == 16'hFFB0)		?	{2'b00, PALETTE[0][5:0]}:
									(ADDRESS == 16'hFFB1)		?	{2'b00, PALETTE[1][5:0]}:
									(ADDRESS == 16'hFFB2)		?	{2'b00, PALETTE[2][5:0]}:
									(ADDRESS == 16'hFFB3)		?	{2'b00, PALETTE[3][5:0]}:
									(ADDRESS == 16'hFFB4)		?	{2'b00, PALETTE[4][5:0]}:
									(ADDRESS == 16'hFFB5)		?	{2'b00, PALETTE[5][5:0]}:
									(ADDRESS == 16'hFFB6)		?	{2'b00, PALETTE[6][5:0]}:
									(ADDRESS == 16'hFFB7)		?	{2'b00, PALETTE[7][5:0]}:
									(ADDRESS == 16'hFFB8)		?	{2'b00, PALETTE[8][5:0]}:
									(ADDRESS == 16'hFFB9)		?	{2'b00, PALETTE[9][5:0]}:
									(ADDRESS == 16'hFFBA)		?	{2'b00, PALETTE[10][5:0]}:
									(ADDRESS == 16'hFFBB)		?	{2'b00, PALETTE[11][5:0]}:
									(ADDRESS == 16'hFFBC)		?	{2'b00, PALETTE[12][5:0]}:
									(ADDRESS == 16'hFFBD)		?	{2'b00, PALETTE[13][5:0]}:
									(ADDRESS == 16'hFFBE)		?	{2'b00, PALETTE[14][5:0]}:
									(ADDRESS == 16'hFFBF)		?	{2'b00, PALETTE[15][5:0]}:
									(ADDRESS == 16'hFFC0)		?	{3'b000, CENT}:
									(ADDRESS == 16'hFFC1)		?	{1'b0, YEAR}:
									(ADDRESS == 16'hFFC2)		?	{4'h0, MNTH}:
									(ADDRESS == 16'hFFC3)		?	{3'b000, DMTH}:
									(ADDRESS == 16'hFFC4)		?	{5'b00000, DWK}:
									(ADDRESS == 16'hFFC5)		?	{3'b000, HOUR}:
									(ADDRESS == 16'hFFC6)		?	{2'b00, MIN}:
									(ADDRESS == 16'hFFC7)		?	{2'b00, SEC}:

									(ADDRESS == 16'hFFCC)		?	{KEY[51],KEY[52],KEY[72],KEY[71],
																			 KEY[28],KEY[27],KEY[30],KEY[29]}:
									(ADDRESS == 16'hFFCD)		?	{KEY[70],KEY[69],KEY[65],KEY[66],
																			 KEY[67],KEY[68],2'b00}:
									(ADDRESS == 16'hFFCE)		?	{KEY[61],KEY[60],KEY[59],KEY[58],
																			 KEY[57],KEY[56],KEY[54],KEY[53]}:
									(ADDRESS == 16'hFFCF)		?	{!V_SYNC,VBLANK,!H_SYNC,HBLANK,
																			 KEY[0],KEY[64],KEY[63],KEY[62]}:

									(ADDRESS == 16'hFFF0)		?	Version_Hi:
`ifdef M5Meg
									(ADDRESS == 16'hFFF1)		?	(Version_Lo + 8'h05):
`endif
`ifdef M1Meg
									(ADDRESS == 16'hFFF1)		?	(Version_Lo + 8'h01):
`endif
									(ADDRESS == 16'hFFF2)		?	8'hFE:
									(ADDRESS == 16'hFFF3)		?	8'hEE:
									(ADDRESS == 16'hFFF4)		?	8'hFE:
									(ADDRESS == 16'hFFF5)		?	8'hF1:
									(ADDRESS == 16'hFFF6)		?	8'hFE:
									(ADDRESS == 16'hFFF7)		?	8'hF4:
									(ADDRESS == 16'hFFF8)		?	8'hFE:
									(ADDRESS == 16'hFFF9)		?	8'hF7:
									(ADDRESS == 16'hFFFA)		?	8'hFE:
									(ADDRESS == 16'hFFFB)		?	8'hFA:
									(ADDRESS == 16'hFFFC)		?	8'hFE:
									(ADDRESS == 16'hFFFD)		?	8'hFD:
									(ADDRESS == 16'hFFFE)		?	8'h8C:
									(ADDRESS == 16'hFFFF)		?	8'h1B:

																	8'h55;

assign	DATA_REG1	= !DDR1	?	DD_REG1:
											KEYBOARD_IN;

assign	DATA_REG2	= !DDR2	?	DD_REG2:
											KEY_COLUMN;

assign	DATA_REG3	= !DDR3	?	DD_REG3:
											{DTOA_CODE, 1'b1, 1'b1};

// A 0 in the DDR makes that pin an input
assign	BIT3 			= !DD_REG4[3]	?	1'b0:
													CSS;
assign	DATA_REG4	= !DDR4	?	DD_REG4:
											{VDG_CONTROL, BIT3, KEY_COLUMN[6], SBS, 1'b1};
/********************************************************************************
*	SDRAM Interface
*********************************************************************************/
//      -- Host side
sdramCntl SDRAM(
.clk(CLK50MHZ),					//in  std_logic;  -- master clock
.lock(RESET_N),					//in  std_logic;  -- true if clock is stable
.rst(CPU_RESET),					//in  std_logic;  -- reset
.rd(SDRAM_RD),						//in  std_logic;  -- initiate read operation
.wr(SDRAM_WR),						//in  std_logic;  -- initiate write operation
.earlyOpBegun(SDRAM_EOB),		//out std_logic;  -- read/write/self-refresh op has begun (async)
.opBegun(SDRAM_OB),				//out std_logic;  -- read/write/self-refresh op has begun (clocked)
.rdPending(SDRAM_RDP),			//out std_logic;  -- true if read operation(s) are still in the pipeline
.done(SDRAM_DONE),				//out std_logic;  -- read or write operation is done
.rdDone(SDRAM_RDD),				//out std_logic;  -- read operation is done and data is available
.hAddr(SDRAM_ADDR),				//in  std_logic_vector(HADDR_WIDTH-1 downto 0);  -- address from host to SDRAM
.hDIn(SDRAM_DIN),					//in  std_logic_vector(DATA_WIDTH-1 downto 0);  -- data from host to SDRAM
.hDOut(HDOUT),						//out std_logic_vector(DATA_WIDTH-1 downto 0);  -- data from SDRAM to host
.status(SDRAM_STATUS),			//out std_logic_vector(3 downto 0);  -- diagnostic status of the FSM
//      -- SDRAM side
.cke(SDRAM_CKE),					//out std_logic;  -- clock-enable to SDRAM
.ce_n(SDRAM_CS_N),				//out std_logic;  -- chip-select to SDRAM
.ras_n(SDRAM_RAS_N),				//out std_logic;  -- SDRAM row address strobe
.cas_n(SDRAM_CAS_N),				//out std_logic;  -- SDRAM column address strobe
.we_n(SDRAM_RW_N),				//out std_logic;  -- SDRAM write enable
.ba(SDRAM_BANK),					//out std_logic_vector(1 downto 0);  -- SDRAM bank address
.sAddr(SDRAM_ADDRESS),			//out std_logic_vector(SADDR_WIDTH-1 downto 0);  -- SDRAM row/column address
.sDIn(SDRAM_DATA),				//in  std_logic_vector(DATA_WIDTH-1 downto 0);  -- data from SDRAM
.sDOut(SDRAM_DATA_BUF),			//out std_logic_vector(DATA_WIDTH-1 downto 0);  -- data to SDRAM
.sDOutEn(SDRAM_DATA_BUF_EN),	//out std_logic;  -- true if data is output to SDRAM on sDOut
.dqmh(SDRAM_UDQM),				//out std_logic;  -- enable upper-byte of SDRAM databus if true
.dqml(SDRAM_LDQM)					//out std_logic  -- enable lower-byte of SDRAM databus if true
);

assign SDRAM_CLK = CLK50MHZ;
assign SDRAM_DATA = (SDRAM_DATA_BUF_EN)	?	SDRAM_DATA_BUF:
														16'bZZZZZZZZZZZZZZZZ;
assign SDRAM_NEXT = (SDRAM_STATE == 3'b000);
always @ (posedge CLK50MHZ or negedge RESET_N)
begin
	if(!RESET_N)
	begin
		SDRAM_STATE <= 3'b000;
		SDRAM_RD <= 1'b0;
		SDRAM_WR <= 1'b0;
		SDRAM_DOUT <= 16'h0000;
		SDRAM_START_BUF <= 2'b00;
	end
	else
	begin
		SDRAM_START_BUF <= {SDRAM_START_BUF[0], SDRAM_START};
		case (SDRAM_STATE)
		3'b000:
		begin
			if(!SDRAM_START_BUF[1])
				SDRAM_STATE <= 3'b001;
		end
		3'b001:
		begin
			if(SDRAM_START_BUF[1])
			begin
				if(SDRAM_READ)
				begin
					SDRAM_STATE <= 3'b010;
					SDRAM_RD <= 1'b1;
				end
				else
				begin
					SDRAM_STATE <= 3'b101;
					SDRAM_WR <= 1'b1;
				end
			end
		end
// Read
		3'b010:
		begin
			if(SDRAM_OB)
			begin
				SDRAM_RD <= 1'b0;
				SDRAM_STATE <= 3'b011;
			end
		end
		3'b011:
		begin
			if(SDRAM_DONE)
				SDRAM_STATE <= 3'b100;
		end
		3'b100:
		begin
			SDRAM_DOUT <= HDOUT;
			SDRAM_STATE <= 3'b000;
		end
// Write
		3'b101:
		begin
			if(SDRAM_OB)
			begin
				SDRAM_WR <= 1'b0;
				SDRAM_STATE <= 3'b110;
			end
		end
		3'b110:
		begin
			if(SDRAM_DONE)
			begin
				SDRAM_STATE <= 3'b000;
			end
		end
		3'b111:
		begin
			SDRAM_STATE <= 3'b000;
		end
		endcase
	end
end

always @ (negedge PH_2 or negedge RESET_N)
begin
	if(!RESET_N)
	begin
		SDRAM_ADDR[6:0] <= 7'h00;
		SDRAM_START <= 1'b0;
	end
	else
	begin
		SDRAM_NEXT_BUF <= {SDRAM_NEXT_BUF[0], SDRAM_NEXT};
		if(ADDRESS[15:0] == 16'hFF88)
			SDRAM_ADDR[6:0] <= 7'h00;
		else
			if(ADDRESS[15:0] == 16'hFF86)							// Does not matter if read or write
			begin
				SDRAM_ADDR[6:0] <= SDRAM_ADDR[6:0] + 1'b1;
				SDRAM_START <= 1'b1;
			end
			else
				if(SDRAM_NEXT_BUF[1])
					SDRAM_START <= 1'b0;
	end
end
		
// Clock for Drivewire UART on the slave processor(6850)
// 8 cycles in 50 MHz / 27 = 8*50/27 = 14.815 MHz
always @(negedge CLK50MHZ or negedge RESET_N)
begin
	if(!RESET_N)
	begin
		COM1_STATE <= 5'h00;
		COM1_CLOCK_X <= 1'b0;
	end
	else
	begin
		case (COM1_STATE)
		5'h00:
		begin
			COM1_STATE <= 5'h01;
			COM1_CLOCK_X <= 1'b0;
		end
		5'h01:
		begin
			COM1_STATE <= 5'h02;
			COM1_CLOCK_X <= 1'b1;
		end
		5'h02:
		begin
			COM1_STATE <= 5'h03;
			COM1_CLOCK_X <= 1'b0;
		end
		5'h04:
		begin
			COM1_STATE <= 5'h05;
			COM1_CLOCK_X <= 1'b1;
		end
		5'h05:
		begin
			COM1_STATE <= 5'h06;
			COM1_CLOCK_X <= 1'b0;
		end
		5'h07:
		begin
			COM1_STATE <= 5'h08;
			COM1_CLOCK_X <= 1'b1;
		end
		5'h09:
		begin
			COM1_STATE <= 5'h0A;
			COM1_CLOCK_X <= 1'b0;
		end
		5'h0B:
		begin
			COM1_STATE <= 5'h0C;
			COM1_CLOCK_X <= 1'b1;
		end
		5'h0C:
		begin
			COM1_STATE <= 5'h0D;
			COM1_CLOCK_X <= 1'b0;
		end
		5'h0E:
		begin
			COM1_STATE <= 5'h0F;
			COM1_CLOCK_X <= 1'b1;
		end
		5'h0F:
		begin
			COM1_STATE <= 5'h10;
			COM1_CLOCK_X <= 1'b0;
		end
		5'h11:
		begin
			COM1_STATE <= 5'h12;
			COM1_CLOCK_X <= 1'b1;
		end
		5'h13:
		begin
			COM1_STATE <= 5'h14;
			COM1_CLOCK_X <= 1'b0;
		end
		5'h15:
		begin
			COM1_STATE <= 5'h16;
			COM1_CLOCK_X <= 1'b1;
		end
		5'h16:
		begin
			COM1_STATE <= 5'h17;
			COM1_CLOCK_X <= 1'b0;
		end
		5'h18:
		begin
			COM1_STATE <= 5'h19;
			COM1_CLOCK_X <= 1'b1;
		end
		5'h1A:
		begin
			COM1_STATE <= 5'h00;
			COM1_CLOCK_X <= 1'b0;
		end
		5'h1F:
		begin
			COM1_STATE <= 5'h00;
			COM1_CLOCK_X <= 1'b0;
		end
		default:
		begin
			COM1_STATE <= COM1_STATE + 1'b1;
		end
		endcase
	end
end

//Switch selectable baud rate
always @(negedge COM1_CLOCK_X or negedge RESET_N)
begin
	if(!RESET_N)
	begin
		COM1_CLK <= 3'b000;
		COM1_CLOCK <= 1'b0;
	end
	else
	begin
		case (COM1_CLK)
		3'b000:
		begin
			COM1_CLOCK <= 1'b1;
			COM1_CLK <= 3'b001;
		end
		3'b001:
		begin
			COM1_CLOCK <= 1'b0;
			if(SWITCH[8:7]==2'b10)				// divide by 2 460800  = 14.8148 / 2 /16 = 462962.963 = +0.2084335%
				COM1_CLK <= 3'b000;
			else
				COM1_CLK <= 3'b010;
		end
		3'b011:
		begin
			COM1_CLOCK <= 1'b0;
			if(SWITCH[8:7]==2'b01)				// divide by 4 230400
				COM1_CLK <= 3'b000;
			else
				COM1_CLK <= 3'b100;
		end
		3'b111:									// divide by 8 115200
		begin
			COM1_CLK <= 3'b000;
		end
		default:
		begin
			COM1_CLK <= COM1_CLK + 1'b1;
		end
		endcase
	end
end

//Switch selectable WiFi baud rate
always @(negedge COM1_CLOCK_X or negedge RESET_N)
begin
	if(!RESET_N)
	begin
		WF_CLOCK <= 1'b0;
		COM2_CLK <= 6'h00;
	end
	else
	begin
		case (COM2_CLK)
		6'h00:
		begin
			WF_CLOCK <= !WF_CLOCK;
			COM2_CLK <= 6'h01;
		end
		6'h03:									// divide by 4 / 2 = 115200
		begin
			if( WF_BAUD )
				COM2_CLK <= 6'h00;
			else
				COM2_CLK <= 6'h04;
		end
		6'h2F:									// divide by 48 / 2 = 9600
		begin
			COM2_CLK <= 4'h00;
		end
		default:
		begin
			COM2_CLK <= COM2_CLK + 1'b1;
		end
		endcase
	end
end

// Combinatorial clock :(
assign UART1_CLK = (SWITCH[8:7] == 2'b11)	?	COM1_CLOCK_X:	// 921600
															COM1_CLOCK;

// Clock for RS232 PAK (6551)
// 24 MHz / 13 = 1.846 MHz
always @(negedge CLK24MHZ or negedge RESET_N)
begin
	if(!RESET_N)
	begin
		COM2_STATE <= 13'b0000000000001;
	end
	else
	begin
//		case (COM2_STATE)
//		13'b0000001000000:
//		begin
//			COM2_STATE <= {COM2_STATE[11:0],COM2_STATE[12]};
//		end
//		default:
//		begin
			COM2_STATE <= {COM2_STATE[11:0],COM2_STATE[12]};
//		end
//		endcase
	end
end
//BANKS
// CPU clock / SRAM Signals for old SRAM
always @(negedge CLK50MHZ or negedge RESET_N)
begin
	if(!RESET_N)
	begin
		CLK <= 6'h00;
		SWITCH_L <= 2'b00;
		PH_2_RAW <= 1'b0;
		RAM0_RW_N <= 1'b1;
		RAM1_RW0_N <= 1'b1;
		RAM1_RW1_N <= 1'b1;
		RAM0_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
		RAM1_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
		RAM0_BE0_N <=  1'b1;
		RAM0_BE1_N <= 1'b1;
		RAM1_BE0_N <=  1'b1;
		RAM1_BE1_N <= 1'b1;
		RAM1_BE2_N <=  1'b1;
		RAM1_BE3_N <= 1'b1;
	end
	else
	begin
		case (CLK)
		6'h00:
		begin
			SWITCH_L <= {SWITCH[0], RATE};					// Normal speed
			PH_2_RAW <= 1'b1;
// Grab video one more time
`ifdef M5Meg
			if(VIDEO_ADDRESS[21])
				VIDEO_BUFFER <= RAM0_DATA;
			else
				VIDEO_BUFFER <= RAM1_DATA;
`endif
`ifdef M1Meg
				VIDEO_BUFFER <= RAM0_DATA;
`endif
`ifdef M4Meg
				VIDEO_BUFFER <= RAM1_DATA;
`endif
			CLK <= 6'h01;
//			RAM0_RW_N <= RW_N;
//			RAM1_RW0_N <= RW_N;
//			RAM1_RW1_N <= RW_N;
			RAM0_BE0_N <=  !RAM0_BE0;
			RAM0_BE1_N <=  !RAM0_BE1;
			RAM1_BE0_N <=  !RAM1_BE0;
			RAM1_BE1_N <=  !RAM1_BE1;
			RAM1_BE2_N <=  !RAM1_BE2;
			RAM1_BE3_N <=  !RAM1_BE3;
//***************************************
// Gart
//***************************************
			if(ADDRESS[15:0]==16'hFF73)
			begin
				RAM0_RW_N <= RW_N;
				RAM1_RW0_N <= RW_N;
				RAM1_RW1_N <= RW_N;
				if(!RW_N)
				begin
					RAM0_ADDRESS <= GART_WRITE[20:1];
					RAM1_ADDRESS <= GART_WRITE[20:1];
					RAM1_ADDRESS9_1 <= GART_WRITE[10];
					RAM1_ADDRESS10_1 <= GART_WRITE[11];
				end
				else
				begin
					RAM0_ADDRESS <= GART_READ[20:1];
					RAM1_ADDRESS <= GART_READ[20:1];
					RAM1_ADDRESS9_1 <= GART_READ[10];
					RAM1_ADDRESS10_1 <= GART_READ[11];
				end
				if (!RW_N)
				begin
					RAM0_DATA[15:0] <= {DATA_OUT, DATA_OUT};
					RAM1_DATA[15:0] <= {DATA_OUT, DATA_OUT};
				end
				else
				begin
					RAM0_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
					RAM1_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
				end
			end
			else
			begin
				if(!VMA & (GART_CNT != 17'h00000))
				begin
					if(GART_CNT[0])
					begin
						RAM0_RW_N <= 1'b0;
						RAM1_RW0_N <= 1'b0;
						RAM1_RW1_N <= 1'b0;
						RAM0_ADDRESS <= GART_WRITE[20:1];
						RAM1_ADDRESS <= GART_WRITE[20:1];
						RAM1_ADDRESS9_1 <= GART_WRITE[10];
						RAM1_ADDRESS10_1 <= GART_WRITE[11];
						RAM0_DATA[15:0] <= {GART_BUF, GART_BUF};
						RAM1_DATA[15:0] <= {GART_BUF, GART_BUF};
					end
					else
					begin
						RAM0_RW_N <= 1'b1;
						RAM1_RW0_N <= 1'b1;
						RAM1_RW1_N <= 1'b1;
						RAM0_ADDRESS <= GART_READ[20:1];
						RAM1_ADDRESS <= GART_READ[20:1];
						RAM1_ADDRESS9_1 <= GART_READ[10];
						RAM1_ADDRESS10_1 <= GART_READ[11];
						RAM0_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
						RAM1_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
					end
				end
				else
				begin
					RAM0_RW_N <= RW_N;
					RAM1_RW0_N <= RW_N;
					RAM1_RW1_N <= RW_N;
					RAM0_ADDRESS <= {BLOCK_ADDRESS[7:0], ADDRESS[12:1]};
					RAM1_ADDRESS <= {BLOCK_ADDRESS[7:0], ADDRESS[12:1]};
					RAM1_ADDRESS9_1 <= ADDRESS[10];
					RAM1_ADDRESS10_1 <= ADDRESS[11];
					if (!RW_N)
					begin
						RAM0_DATA[15:0] <= {DATA_OUT, DATA_OUT};
						RAM1_DATA[15:0] <= {DATA_OUT, DATA_OUT};
					end
					else
					begin
						RAM0_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
						RAM1_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
					end
				end
			end
		end
		6'h01:
		begin
			if(!VMA & !GART_CNT[0])
			begin
				GART_BUF <= DATA_IN;
			end
			PH_2_RAW <= 1'b0;
			RAM0_ADDRESS <= VIDEO_ADDRESS[19:0];
			RAM1_ADDRESS <= VIDEO_ADDRESS[19:0];
			RAM1_ADDRESS9_1 <= VIDEO_ADDRESS[9];
			RAM1_ADDRESS10_1 <= VIDEO_ADDRESS[10];
`ifdef M5Meg
			RAM0_BE0_N <= !( VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM0_BE1_N <= !( VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE2_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
			RAM1_BE3_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
`endif
`ifdef M1Meg
			RAM0_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM0_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE0_N <= 1'b1;
			RAM1_BE1_N <= 1'b1;
			RAM1_BE2_N <= 1'b1;
			RAM1_BE3_N <= 1'b1;
`endif
`ifdef M4Meg
			RAM0_BE0_N <= 1'b1;
			RAM0_BE1_N <= 1'b1;
			RAM1_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE2_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
			RAM1_BE3_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
`endif

			RAM0_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
			RAM1_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
			RAM0_RW_N <= 1'b1;
			RAM1_RW0_N <= 1'b1;
			RAM1_RW1_N <= 1'b1;
			if({SWITCH_L} == 2'b11)		//50/2 = 25 
				CLK <= 6'h00;
			else
				CLK <= 6'h02;
		end
		6'h1B:								//	50/28 = 1.7857
		begin
			RAM0_ADDRESS <= VIDEO_ADDRESS[19:0];
			RAM1_ADDRESS <= VIDEO_ADDRESS[19:0];
			RAM1_ADDRESS9_1 <= VIDEO_ADDRESS[9];
			RAM1_ADDRESS10_1 <= VIDEO_ADDRESS[10];

`ifdef M5Meg
			RAM0_BE0_N <= !( VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM0_BE1_N <= !( VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE2_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
			RAM1_BE3_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
`endif
`ifdef M1Meg
			RAM0_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM0_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE0_N <= 1'b1;
			RAM1_BE1_N <= 1'b1;
			RAM1_BE2_N <= 1'b1;
			RAM1_BE3_N <= 1'b1;
`endif
`ifdef M4Meg
			RAM0_BE0_N <= 1'b1;
			RAM0_BE1_N <= 1'b1;
			RAM1_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE2_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
			RAM1_BE3_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
`endif
			RAM0_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
			RAM1_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
`ifdef M5Meg
			if(VIDEO_ADDRESS[21])
				VIDEO_BUFFER <= RAM0_DATA;
			else
				VIDEO_BUFFER <= RAM1_DATA;
`endif
`ifdef M1Meg
				VIDEO_BUFFER <= RAM0_DATA;
`endif
`ifdef M4Meg
				VIDEO_BUFFER <= RAM1_DATA;
`endif
			if(SWITCH_L[0])				//Rate = 1?
				CLK <= 6'h00;
			else
				CLK <= 6'h1C;
		end
		6'h37:								// 50/56 = 0.89286
		begin
			RAM0_ADDRESS <= VIDEO_ADDRESS[19:0];
			RAM1_ADDRESS <= VIDEO_ADDRESS[19:0];
			RAM1_ADDRESS9_1 <= VIDEO_ADDRESS[9];
			RAM1_ADDRESS10_1 <= VIDEO_ADDRESS[10];
`ifdef M5Meg
			RAM0_BE0_N <= !( VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM0_BE1_N <= !( VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE2_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
			RAM1_BE3_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
`endif
`ifdef M1Meg
			RAM0_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM0_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE0_N <= 1'b1;
			RAM1_BE1_N <= 1'b1;
			RAM1_BE2_N <= 1'b1;
			RAM1_BE3_N <= 1'b1;
`endif
`ifdef M4Meg
			RAM0_BE0_N <= 1'b1;
			RAM0_BE1_N <= 1'b1;
			RAM1_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE2_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
			RAM1_BE3_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
`endif
			RAM0_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
			RAM1_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
`ifdef M5Meg
			if(VIDEO_ADDRESS[21])
				VIDEO_BUFFER <= RAM0_DATA;
			else
				VIDEO_BUFFER <= RAM1_DATA;
`endif
`ifdef M1Meg
				VIDEO_BUFFER <= RAM0_DATA;
`endif
`ifdef M4Meg
				VIDEO_BUFFER <= RAM1_DATA;
`endif
			CLK <= 6'h00;
		end
		6'h3F:								// Just in case
		begin
			CLK <= 6'h00;
		end
		default:
		begin
			CLK <= CLK + 1'b1;
			RAM0_ADDRESS <= VIDEO_ADDRESS[19:0];
			RAM1_ADDRESS <= VIDEO_ADDRESS[19:0];
			RAM1_ADDRESS9_1 <= VIDEO_ADDRESS[9];
			RAM1_ADDRESS10_1 <= VIDEO_ADDRESS[10];
`ifdef M5Meg
			RAM0_BE0_N <= !( VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM0_BE1_N <= !( VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE2_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
			RAM1_BE3_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
`endif
`ifdef M1Meg
			RAM0_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM0_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE0_N <= 1'b1;
			RAM1_BE1_N <= 1'b1;
			RAM1_BE2_N <= 1'b1;
			RAM1_BE3_N <= 1'b1;
`endif
`ifdef M4Meg
			RAM0_BE0_N <= 1'b1;
			RAM0_BE1_N <= 1'b1;
			RAM1_BE0_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE1_N <= !(!VIDEO_ADDRESS[21] & !VIDEO_ADDRESS[20]);
			RAM1_BE2_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
			RAM1_BE3_N <= !(!VIDEO_ADDRESS[21] &  VIDEO_ADDRESS[20]);
`endif
			RAM0_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
			RAM1_DATA[15:0] <= 16'bZZZZZZZZZZZZZZZZ;
`ifdef M5Meg
			if(VIDEO_ADDRESS[21])
				VIDEO_BUFFER <= RAM0_DATA;
			else
				VIDEO_BUFFER <= RAM1_DATA;
`endif
`ifdef M1Meg
				VIDEO_BUFFER <= RAM0_DATA;
`endif
`ifdef M4Meg
				VIDEO_BUFFER <= RAM1_DATA;
`endif
		end
		endcase
	end
end

// Make sure PH2 is a Global Clock
PH2_CLK	PH2_CLK_inst (
	.inclk ( PH_2_RAW ),
	.outclk ( PH_2 )
	);

assign RESET_P =	!BUTTON_N[3]					// Button
						| RESET;							// CTRL-ALT-DEL

// Make sure all resets are enabled for a long enough time to allow voltages to settle
always @ (negedge MCLOCK[8] or posedge RESET_P)		// 50 MHz / 64
begin
	if(RESET_P)
	begin
		RESET_SM <= 14'h0000;
		CPU_RESET <= 1'b1;
		RESET_N <= 1'b0;
	end
	else
		case (RESET_SM)
		14'h3800:									// time = 1.28 uS * 14336 = 18350.08 uS
		begin
			RESET_N <= 1'b1;
			CPU_RESET <= 1'b1;
			RESET_SM <= 14'h3801;
		end
		14'h3FFF:									// time = 1.28 uS * 16383 = 20970.24 uS
		begin
			RESET_N <= 1'b1;
			CPU_RESET <= 1'b0;
			RESET_SM <= 14'h3FFF;
		end
		default:
			RESET_SM <= RESET_SM + 1'b1;
		endcase
end

// CPU section copyrighted by John Kent
CPU09 GLBCPU09(
	.clk(PH_2),
	.rst(CPU_RESET),
	.vma(VMA),
	.addr(ADDRESS),
	.rw(RW_N),
	.data_in(DATA_IN),
	.data_out(DATA_OUT),
	.halt(HALT_BUF2),
	.hold(1'b0),
	.irq(!CPU_IRQ),
	.firq(!CPU_FIRQ),
	.nmi(NMI_09)
);

// Disk Drive Controller / Slave processor
`include "..\CoCo3FPGA_Common\CoCo3IO.v"

// Interrupt source for CART signal
always @(negedge PH_2 or negedge RESET_N)
begin
	if(!RESET_N)
	begin
		CART_IRQ <= 1'b1;
	end
	else
	begin
		case (MPI_SCS)
		2'b00:
			CART_IRQ <=  (!CART_IRQ | SWITCH[4])
							&(!IRQ_09 & IRQ_SPI_N & SER_IRQ);
		2'b01:
			CART_IRQ <= (!IRQ_09 & IRQ_SPI_N & SER_IRQ);
		2'b10:
			CART_IRQ <= (!CART_IRQ | SWITCH[4])
							&(!IRQ_09 & IRQ_SPI_N & SER_IRQ);
		2'b11:
			CART_IRQ <= (!IRQ_09 & IRQ_SPI_N & SER_IRQ);
		endcase
	end
end
//***********************************************************************
// Interrupt latches
//***********************************************************************
// INT for COCO1
always @ (negedge PH_2)
begin
// H_SYNC int for COCO1
// output	HS_INT
// State		HS_INT_SM
// input		H_SYNC / H_FLAG
// switch	HSYNC_INT @ FF01
// pol		HSYNC_POL
// clear    FF00

		if(!RESET_N)
		begin
			HS_INT <= 1'b1;				// No flag
			H_SYNC_IRQ_N <= 1'b1;			// no int
// Start SM at last step to makse sure you see a deasserted trigger
// before triggering the first time
			HS_INT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (HS_INT_SM)
			2'b00:
			begin
				if((!H_SYNC ^ HSYNC_POL) & H_FLAG)		// 1 = int
				begin
					HS_INT <= 1'b0;
					H_SYNC_IRQ_N <= !HSYNC_INT;
					HS_INT_SM <= 2'b01;
				end
//				else not needed
//				begin
//					HS_INT <= 1'b1;			// no int
//					H_SYNC_IRQ_N <= 1'b1;
//					HS_INT_SM <= 2'b00;
//				end
			end
			2'b01:
			begin
				if({ADDRESS[15:5], ADDRESS[1:0]} == 13'b1111111100000)		// FF00, FF04, FF08, FF0C, FF10, FF14, FF18, FF1C
				begin
					HS_INT <= 1'b1;
					H_SYNC_IRQ_N <= 1'b1;
					HS_INT_SM <= 2'b10;
				end
				else
				begin
					H_SYNC_IRQ_N <= !HSYNC_INT;
				end
			end
			2'b10:
			begin
				if(!((!H_SYNC ^ HSYNC_POL) & H_FLAG))
				begin
					HS_INT <= 1'b1;
					H_SYNC_IRQ_N <= 1'b1;
					HS_INT_SM <= 2'b00;
				end
			end
			endcase
		end
end

always @ (negedge PH_2) //  or negedge RESET_N)
begin
// V_SYNC int for COCO1
// Start of Sync is a 1 to 0
// output	VS_INT
// State		VS_INT_SM
// input		V_SYNC
// switch	VSYNC_INT @ FF03
// pol		VSYNC_POL
// clear    FF02

		if(!RESET_N)		// disabled
		begin
			VS_INT <= 1'b1;			// no int
			V_SYNC_IRQ_N <= 1'b1;
// Start SM at last step to makse sure you see a deasserted trigger
// before triggering the first time
			VS_INT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (VS_INT_SM)
			2'b00:
			begin
				if(!V_SYNC ^ VSYNC_POL)		// 1 = int
				begin
					VS_INT <= 1'b0;
					V_SYNC_IRQ_N <= !VSYNC_INT;
					VS_INT_SM <= 2'b01;
				end
//				else
//				begin
//					VS_INT <= 1'b1;			// no int
//					V_SYNC_IRQ_N <= 1'b1;
//					VS_INT_SM <= 2'b00;
//				end
			end
			2'b01:
			begin
				if({ADDRESS[15:5], ADDRESS[1:0]} == 13'b1111111100010)		// FF02, FF06, FF0A, FF0E, FF12, FF16, FF1A, FF1E
				begin
					VS_INT <= 1'b1;
					V_SYNC_IRQ_N <= 1'b1;
					VS_INT_SM <= 2'b10;
				end
				else
				begin
					V_SYNC_IRQ_N <= !VSYNC_INT;
				end
			end
			2'b10:
			begin
				if(!(!V_SYNC ^ VSYNC_POL))
				begin
					VS_INT <= 1'b1;
					V_SYNC_IRQ_N <= 1'b1;
					VS_INT_SM <= 2'b00;
				end
			end
			endcase
		end
end

always @ (negedge PH_2) //  or negedge RESET_N)
begin
// Cart int for COCO1
// output	CART1_INT
// State		CART1_INT_SM
// input		CART_IRQ
// switch	CART_INT @ FF23
// pol		CART_POL
// clear    FF22

		if(CART_INT == 1'b0)		// disabled
		begin
			CART1_INT <= 1'b1;			// no int
			CART1_INT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (CART1_INT_SM)
			2'b00:
			begin
				if(!CART_IRQ)
				begin
					CART1_INT <= 1'b0;
					CART1_INT_SM <= 2'b01;
				end
				else
				begin
					CART1_INT <= 1'b1;			// no int
					CART1_INT_SM <= 2'b00;
				end
			end
			2'b01:
			begin
				if({ADDRESS[15:5], ADDRESS[1:0]} == 13'b1111111100110)		// FF22, FF26, FF2A, FF2E, FF32, FF36, FF3A, FF3E
				begin
					CART1_INT <= 1'b1;
					CART1_INT_SM <= 2'b10;
				end
			end
			2'b10:
			begin
				if(CART_IRQ)
				begin
					CART1_INT <= 1'b1;
					CART1_INT_SM <= 2'b00;
				end
			end
			endcase
		end
end


// INT for COCO3
always @ (negedge PH_2) //  or negedge RESET_N)
begin
// TIMER int for COCO3
// output	TMR_INT
// State		TMR_INT_SM
// input		TIMER_N
// switch	IRQ_TMR

		if(IRQ_TMR == 1'b0)		// disabled
		begin
			TMR_INT <= 1'b1;			// no int
			TMR_INT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (TMR_INT_SM)
			2'b00:
			begin
				if(!TIMER_N)
				begin
					TMR_INT <= 1'b0;
					TMR_INT_SM <= 2'b01;
				end
				else
				begin
					TMR_INT <= 1'b1;			// no int
					TMR_INT_SM <= 2'b00;
				end
			end
			2'b01:
			begin
				if({ADDRESS[15:0]} == 16'hFF92)
				begin
					TMR_INT <= 1'b1;
					TMR_INT_SM <= 2'b10;
				end
			end
			2'b10:
			begin
				if(TIMER_N)
				begin
					TMR_INT <= 1'b1;
					TMR_INT_SM <= 2'b00;
				end
			end
			endcase
		end
end

always @ (negedge PH_2) //  or negedge RESET_N)
begin
// H_SYNC int for COCO3
// output	HBORD_INT
// State		HBORD_INT_SM
// input		H_SYNC / H_FLAG
// switch	IRQ_HBORD

		if(IRQ_HBORD == 1'b0)		// disabled
		begin
			HBORD_INT <= 1'b1;			// no int
			HBORD_INT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (HBORD_INT_SM)
			2'b00:
			begin
				if(!H_SYNC & H_FLAG)		// 1 = int
				begin
					HBORD_INT <= 1'b0;
					HBORD_INT_SM <= 2'b01;
				end
				else
				begin
					HBORD_INT <= 1'b1;			// no int
					HBORD_INT_SM <= 2'b00;
				end
			end
			2'b01:
			begin
				if({ADDRESS[15:0]} == 16'HFF92)
				begin
					HBORD_INT <= 1'b1;
					HBORD_INT_SM <= 2'b10;
				end
			end
			2'b10:
			begin
				if(!(!H_SYNC & H_FLAG))
				begin
					HBORD_INT <= 1'b1;
					HBORD_INT_SM <= 2'b00;
				end
			end
			endcase
		end
end
always @ (negedge PH_2) //  or negedge RESET_N)
begin
// V_SYNC int for COCO3
// Start of Sync is a 1 to 0
// output	VBORD_INT
// State		VBORD_INT_SM
// input		V_SYNC
// switch	IRQ_VBORD

		if(IRQ_VBORD == 1'b0)		// disabled
		begin
			VBORD_INT <= 1'b1;			// no int
			VBORD_INT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (VBORD_INT_SM)
			2'b00:
			begin
				if(!V_SYNC)
				begin
					VBORD_INT <= 1'b0;
					VBORD_INT_SM <= 2'b01;
				end
				else
				begin
					VBORD_INT <= 1'b1;			// no int
					VBORD_INT_SM <= 2'b00;
				end
			end
			2'b01:
			begin
				if({ADDRESS[15:0]} == 16'HFF92)
				begin
					VBORD_INT <= 1'b1;
					VBORD_INT_SM <= 2'b10;
				end
			end
			2'b10:
			begin
				if(V_SYNC)
				begin
					VBORD_INT <= 1'b1;
					VBORD_INT_SM <= 2'b00;
				end
			end
			endcase
		end
end

always @ (negedge PH_2) //  or negedge RESET_N)
begin
// Keyboard int for COCO3
// output	KEY_INT
// State		KEY_INT_SM
// input		KEY_INT_RAW
// switch	IRQ_KEY

		if(IRQ_KEY == 1'b0)		// disabled
		begin
			KEY_INT <= 1'b1;			// no int
			KEY_INT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (KEY_INT_SM)
			2'b00:
			begin
				if(!KEY_INT_RAW)
				begin
					KEY_INT <= 1'b0;
					KEY_INT_SM <= 2'b01;
				end
				else
				begin
					KEY_INT <= 1'b1;			// no int
					KEY_INT_SM <= 2'b00;
				end
			end
			2'b01:
			begin
				if({ADDRESS[15:0]} == 16'HFF92)
				begin
					KEY_INT <= 1'b1;
					KEY_INT_SM <= 2'b10;
				end
			end
			2'b10:
			begin
				if(KEY_INT_RAW)
				begin
					KEY_INT <= 1'b1;
					KEY_INT_SM <= 2'b00;
				end
			end
			endcase
		end
end

always @ (negedge PH_2) //  or negedge RESET_N)
begin
// CART (Serial HDD) int for COCO3
// output	CAR_INT
// State		CAR_INT_SM
// input		CART_IRQ
// switch	IRQ_CART
		if(IRQ_CART == 1'b0)		// disabled
		begin
			CAR_INT <= 1'b1;			// no int
			CAR_INT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (CAR_INT_SM)
			2'b00:							// Wait for int
			begin
				if(!CART_IRQ)				// Int in?
				begin							// Yes
					CAR_INT <= 1'b0;
					CAR_INT_SM <= 2'b01;
				end
				else
				begin
					CAR_INT <= 1'b1;			// No int
					CAR_INT_SM <= 2'b00;
				end
			end
			2'b01:
			begin
				if({ADDRESS[15:0]} == 16'HFF92)
				begin
					CAR_INT <= 1'b1;
					CAR_INT_SM <= 2'b10;
				end
			end
			2'b10:
			begin
				if(CART_IRQ)
				begin
					CAR_INT <= 1'b1;
					CAR_INT_SM <= 2'b00;
				end
			end
			endcase
		end
end

// FINT for COCO3
always @ (negedge PH_2) //  or negedge RESET_N)
begin
// TIMER fint for COCO3
// output	TMR_FINT
// State		TMR_FINT_SM
// input		TIMER_N
// switch	FIRQ_TMR

		if(FIRQ_TMR == 1'b0)		// disabled
		begin
			TMR_FINT <= 1'b1;			// no int
			TMR_FINT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (TMR_FINT_SM)
			2'b00:
			begin
				if(!TIMER_N)
				begin
					TMR_FINT <= 1'b0;
					TMR_FINT_SM <= 2'b01;
				end
				else
				begin
					TMR_FINT <= 1'b1;			// no int
					TMR_FINT_SM <= 2'b00;
				end
			end
			2'b01:
			begin
				if({ADDRESS[15:0]} == 16'hFF93)
				begin
					TMR_FINT <= 1'b1;
					TMR_FINT_SM <= 2'b10;
				end
			end
			2'b10:
			begin
				if(TIMER_N)
				begin
					TMR_FINT <= 1'b1;
					TMR_FINT_SM <= 2'b00;
				end
			end
			endcase
		end
end

always @ (negedge PH_2) //  or negedge RESET_N)
begin
// H_SYNC fint for COCO3
// output	HBORD_FINT
// State		HBORD_FINT_SM
// input		H_SYNC / H_FLAG
// switch	FIRQ_HBORD

		if(FIRQ_HBORD == 1'b0)		// disabled
		begin
			HBORD_FINT <= 1'b1;			// no int
			HBORD_FINT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (HBORD_FINT_SM)
			2'b00:
			begin
				if(!H_SYNC & H_FLAG)		// 1 = int
				begin
					HBORD_FINT <= 1'b0;
					HBORD_FINT_SM <= 2'b01;
				end
				else
				begin
					HBORD_FINT <= 1'b1;			// no int
					HBORD_FINT_SM <= 2'b00;
				end
			end
			2'b01:
			begin
				if({ADDRESS[15:0]} == 16'HFF93)
				begin
					HBORD_FINT <= 1'b1;
					HBORD_FINT_SM <= 2'b10;
				end
			end
			2'b10:
			begin
				if((H_SYNC & H_FLAG))
				begin
					HBORD_FINT <= 1'b1;
					HBORD_FINT_SM <= 2'b00;
				end
			end
			endcase
		end
end

always @ (negedge PH_2) //  or negedge RESET_N)
begin
// V_SYNC int for COCO3
// Start of Sync is a 1 to 0
// output	VBORD_FINT
// State		VBORD_FINT_SM
// input		V_SYNC
// switch	FIRQ_VBORD

		if(FIRQ_VBORD == 1'b0)		// disabled
		begin
			VBORD_FINT <= 1'b1;			// no int
			VBORD_FINT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (VBORD_FINT_SM)
			2'b00:
			begin
				if(!V_SYNC)
				begin
					VBORD_FINT <= 1'b0;
					VBORD_FINT_SM <= 2'b01;
				end
				else
				begin
					VBORD_FINT <= 1'b1;			// no int
					VBORD_FINT_SM <= 2'b00;
				end
			end
			2'b01:
			begin
				if({ADDRESS[15:0]} == 16'HFF93)
				begin
					VBORD_FINT <= 1'b1;
					VBORD_FINT_SM <= 2'b10;
				end
			end
			2'b10:
			begin
				if(V_SYNC)
				begin
					VBORD_FINT <= 1'b1;
					VBORD_FINT_SM <= 2'b00;
				end
			end
			endcase
		end
end

always @ (negedge PH_2) //  or negedge RESET_N)
begin
// Keyboard int for COCO3
// output	KEY_FINT
// State		KEY_FINT_SM
// input		KEY_INT_RAW
// switch	FIRQ_KEY

		if(FIRQ_KEY == 1'b0)		// disabled
		begin
			KEY_FINT <= 1'b1;			// no int
			KEY_FINT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (KEY_FINT_SM)
			2'b00:
			begin
				if(!KEY_INT_RAW)
				begin
					KEY_FINT <= 1'b0;
					KEY_FINT_SM <= 2'b01;
				end
				else
				begin
					KEY_FINT <= 1'b1;			// no int
					KEY_FINT_SM <= 2'b00;
				end
			end
			2'b01:
			begin
				if({ADDRESS[15:0]} == 16'HFF93)
				begin
					KEY_FINT <= 1'b1;
					KEY_FINT_SM <= 2'b10;
				end
			end
			2'b10:
			begin
				if(KEY_INT_RAW)
				begin
					KEY_FINT <= 1'b1;
					KEY_FINT_SM <= 2'b00;
				end
			end
			endcase
		end
end

always @ (negedge PH_2) //  or negedge RESET_N)
begin
// CART (Serial HDD) int for COCO3
// output	CAR_FINT
// State		CAR_FINT_SM
// input		CART_FINT
// switch	FIRQ_CART

		if(FIRQ_CART == 1'b0)		// disabled
		begin
			CAR_FINT <= 1'b1;			// no int
			CAR_FINT_SM <= 2'b10;
		end
		else								// enabled
		begin
			case (CAR_FINT_SM)
			2'b00:
			begin
				if(!CART_IRQ)
				begin
					CAR_FINT <= 1'b0;
					CAR_FINT_SM <= 2'b01;
				end
				else
				begin
					CAR_FINT <= 1'b1;			// no int
					CAR_FINT_SM <= 2'b00;
				end
			end
			2'b01:
			begin
				if({ADDRESS[15:0]} == 16'HFF93)
				begin
					CAR_FINT <= 1'b1;
					CAR_FINT_SM <= 2'b10;
				end
			end
			2'b10:
			begin
				if(CART_IRQ)
				begin
					CAR_FINT <= 1'b1;
					CAR_FINT_SM <= 2'b00;
				end
			end
			endcase
		end
end

// Keyboard Interrupt
assign KEY_INT_RAW = (KEYBOARD_IN == 8'hFF)			?	1'b1:
																		1'b0;

// The Cart interrupts had to be modified because they are not self clearing
assign CPU_IRQ =  (H_SYNC_IRQ_N & V_SYNC_IRQ_N)
					&	(!GIME_IRQ  | (TMR_INT  & HBORD_INT  & VBORD_INT  & KEY_INT  & (!IRQ_CART | CART_IRQ)));
assign CPU_FIRQ = (CART1_INT)
					&	(!GIME_FIRQ | (TMR_FINT & HBORD_FINT & VBORD_FINT & KEY_FINT & (!FIRQ_CART | CART_IRQ)));

//Swap the DW and RS232 ports on connectors
assign UART51_RXD =	(!SWITCH[9])	?	OPTRXD:						// Switch 9 off
													DE1RXD;						// Switch 9 on
assign UART50_RXD =	(!SWITCH[9])	?	DE1RXD:						// Switch 9 off
													OPTRXD;						// Switch 9 on
assign DE1TXD =		(!SWITCH[9])	?	UART50_TXD:					// Switch 9 off
													UART51_TXD;					// Switch 8 on
assign OPTTXD =		(!SWITCH[9])	?	UART51_TXD:					// Switch 9 off
													UART50_TXD;					// Switch 8 on

// CoCo3 Programmable timer interrupt
// Strech Timer interrupt for at least 4 CPU clock cycles
assign TIMER_R = !(TIMER == 13'h0000);
always @(negedge PH_2 or negedge TIMER_R)
begin
	if(!TIMER_R)
	begin
		TIMER_STATE <= 2'b00;
		TIMER_N <= 1'b1;
	end
	else
	begin
		case (TIMER_STATE)
		2'b11:
		begin
			TIMER_N <= 1'b1;
		end
		default:
		begin
			TIMER_STATE <= TIMER_STATE + 1'b1;
			TIMER_N <= 1'b0;
		end
		endcase;
	end
end

assign TMR_CLK = !TIMER_INS	?	(H_SYNC | H_FLAG):
											DIV_14;					// 50 MHz / 14 = 3.57 MHz
assign CLK3_57MHZ = DIV_14;
always @ (negedge CLK50MHZ or negedge RESET_N)
begin
	if(!RESET_N)
		DIV_7 <= 3'b000;
	else
	case (DIV_7)
	3'b110:
	begin
		DIV_7 <= 3'b000;
		DIV_14 <= !DIV_14;
	end
	default:
		DIV_7 <= DIV_7 + 1'b1;
	endcase
end

always @(negedge TMR_CLK)
begin
	if(!TMR_ENABLE)
	begin
		BLINK <= 1'b1;
		TIMER <= 13'h1FFF;
	end
	else
		case (TIMER)
		13'h0000:
		begin
			BLINK <= !BLINK;
			TIMER <= 13'h1FFF;
		end
		13'h1FFF: 												//Maybe this should be 1XXX
		begin
// This turns out being TIMER + 1 as in Sockmaster's GIME Reference 1987 GIME
// 0 to TIMER-1 (0 to TIMER-1 is really TIMER counts) + 1 (this is clock going from 0 to 1FFF) = 0 to TIMER+1
				TIMER <= {1'b0,TMR_MSB,TMR_LSB} - 1'b1;
		end
		default:
			TIMER <= TIMER - 1'b1;
		endcase
end
/*
// Special Code to autodetect Analog board
always @ (negedge PH_2 or negedge RESET_N)
begin
	if(!RESET_N)
	begin
		
		SCRN_START_HSB <= 4'h4;		// extra 4 bits for 2MB screen start
		SAM_EXT <= 2'b01;				// extra 2 bits for 8MB SAMs
		ANALOG <= 2'b00;
		PDL_CLK <= 2'b00;
	end
	else
	begin
		if(CPU_RESET)
		begin
			PDL_CLK <= {PDL_CLK[0],PADDLE_CLK[0]};
			case(ANALOG)
			2'b00:
			begin
				if(PDL_CLK[1])
				begin
					ANALOG <= 2'b01;
				end
			end
			2'b01:
			begin
				if(!PDL_CLK[1])
				begin
					ANALOG <= 2'b10;
				end
			end
			2'b10:
			begin
				if(PDL_CLK[1])
				begin
					SCRN_START_HSB <= 4'h0;		// extra 4 bits for 2MB screen start
					SAM_EXT <= 2'b00;				// extra 2 bits for 8MB SAMs
				end
			end
			default:
			begin
				ANALOG <= 2'b00;
			end
			endcase
		end
		else
		begin
			if(!RW_N)
			begin
				case (ADDRESS)
				16'hFF9B:
				begin
					SCRN_START_HSB <= DATA_OUT[3:0];	// extra 4 bits for 8MB screen start
					SAM_EXT <= DATA_OUT[5:4];
				end
				endcase
			end
		end
	end
end
*/
// Most of the latches for settings
always @ (negedge PH_2 or negedge RESET_N)
begin
	if(!RESET_N)
	begin
// FF00
		DD_REG1 <= 8'h00;
// FF01
		HSYNC_INT <= 1'b0;
		HSYNC_POL <= 1'b0;
		DDR1 <= 1'b0;
		SEL[0] <= 1'b0;
// FF02
		DD_REG2 <= 8'h00;
		KEY_COLUMN <= 8'h00;
// FF03
		VSYNC_INT <= 1'b0;
		VSYNC_POL <= 1'b0;
		DDR2 <= 1'b0;
		SEL[1] <= 1'b0;
// FF20
		DD_REG3 <= 8'h00;
		DTOA_CODE <= 6'b000000;
		SOUND_DTOA <= 6'b000000;
//		BBTXD <= 1'b0;
// FF21
		CD_INT <= 1'b0;
		CD_POL <= 1'b0;
		DDR3 <= 1'b0;
		CAS_MTR <= 1'b0;
// FF22
		DD_REG4 <= 8'h00;
		SBS <= 1'b0;
		CSS <= 1'b0;
		VDG_CONTROL <= 4'b0000;
// FF23
		CART_INT <= 1'b0;
		CART_POL <= 1'b0;
		DDR4 <= 1'b0;
		SOUND_EN <= 1'b0;
// FF6C
		WF_IRQ_EN <= 1'b0;
		WF_BAUD <= 1'b0;
// FF70-FF72
		GART_WRITE <= 23'h000000;			// 19' for 512kb
// FF74-FF76
		GART_READ <= 23'h000000;			// 19' for 512kb
// FF77
		GART_INC <= 2'b00;
//	FF78-FF79
		GART_CNT <= 17'h00000;
// FF7A
		ORCH_LEFT <= 8'b10000000;
// FF7B
		ORCH_RIGHT <= 8'b10000000;
// FF7C
		ORCH_LEFT_EXT <= 8'b10000000;
		ORCH_LEFT_EXT_BUF <= 8'b10000000;
// FF7D
		ORCH_RIGHT_EXT <= 8'b10000000;
		ORCH_RIGHT_EXT_BUF <= 8'b10000000;
// FF7F
		W_PROT <= 2'b11;
		MPI_SCS <= SWITCH[2:1];
		MPI_CTS <= SWITCH[2:1];
// FF80
		CK_START <= 1'b0;
// FF81
		CK_DATA_OUT <= 8'h00;
// FF82
		CK_DEVICE <= 8'h00;
// FF83
		CK_REG <= 8'h00;
// FF84
		SDRAM_READ <= 1'b0;
// FF85-FF86
		SDRAM_DIN <= 16'h0000;
// FF87-FF88
		SDRAM_ADDR[21:7] <= 15'h0000;
// FF90
		ROM <= 2'b00;
		ST_SCS <= 1'b0;
		VEC_PAG_RAM <= 1'b0;
		GIME_FIRQ <= 1'b0;
		GIME_IRQ <= 1'b0;
		MMU_EN <= 1'b0;
		COCO1 <= 1'b0;
// FF91
		TIMER_INS <= 1'b0;
		MMU_TR <= 1'b0;
// FF92
		IRQ_TMR <= 1'b0;
		IRQ_HBORD <= 1'b0;
		IRQ_VBORD <= 1'b0;
//		IRQ_SERIAL <= 1'b0;
		IRQ_KEY <= 1'b0;
		IRQ_CART <= 1'b0;
// FF93
		FIRQ_TMR <= 1'b0;
		FIRQ_HBORD <= 1'b0;
		FIRQ_VBORD <= 1'b0;
//		FIRQ_SERIAL <= 1'b0;
		FIRQ_KEY <= 1'b0;
		FIRQ_CART <= 1'b0;
// FF94
		TMR_MSB <= 4'h0;
		TMR_ENABLE <= 1'b0;
// FF95
		TMR_LSB <= 8'h00;
// FF98
		GRMODE <= 1'b0;
		DESCEN <= 1'b0;
		MONO <= 1'b0;
		LPR <= 3'b000;
// FF99
		HLPR <= 1'b0;
		LPF <= 2'b00;
		HRES <= 4'b0000;
		CRES <= 2'b00;
// FF9A
//		BDR_PAL <= 12'h000;
// FF9B
		SCRN_START_HSB <= 4'h0;		// extra 4 bits for 2MB screen start
		SAM_EXT <= 2'b00;				// extra 2 bits for 8MB SAMs
// FF9C
		VERT_FIN_SCRL <= 4'h0;
// FF9D
		SCRN_START_MSB <= 8'h00;
// FF9E
		SCRN_START_LSB <= 8'h00;
// FF9F
		HVEN <= 1'b0;
		HOR_OFFSET <= 7'h00;
// FFA0
		SAM00 <= 10'h000;	// 2MB   6'00 for 512kb
// FFA1
		SAM01 <= 10'h000;
// FFA2
		SAM02 <= 10'h000;
// FFA3
		SAM03 <= 10'h000;
// FFA4
		SAM04 <= 10'h000;
// FFA5
		SAM05 <= 10'h000;
// FFA6
		SAM06 <= 10'h000;
// FFA7
		SAM07 <= 10'h000;
// FFA8
		SAM10 <= 10'h000;
// FFA9
		SAM11 <= 10'h000;
// FFAA
		SAM12 <= 10'h000;
// FFAB
		SAM13 <= 10'h000;
// FFAC
		SAM14 <= 10'h000;
// FFAD
		SAM15 <= 10'h000;
// FFAE
		SAM16 <= 10'h000;
// FFAF
		SAM17 <= 10'h000;
// FFB0
		PALETTE[0] <= 12'h0000;
// FFB1
		PALETTE[1] <= 12'h0000;
// FFB2
		PALETTE[2] <= 12'h000;
// FFB3
		PALETTE[3] <= 12'h000;
// FFB4
		PALETTE[4] <= 12'h000;
// FFB5
		PALETTE[5] <= 12'h000;
// FFB6
		PALETTE[6] <= 12'h000;
// FFB7
		PALETTE[7] <= 12'h000;
// FFB8
		PALETTE[8] <= 12'h000;
// FFB9
		PALETTE[9] <= 12'h000;
// FFBA
		PALETTE[10] <= 12'h000;
// FFBB
		PALETTE[11] <= 12'h000;
// FFBC
		PALETTE[12] <= 12'h000;
// FFBD
		PALETTE[13] <= 12'h000;
// FFBE
		PALETTE[14] <= 12'h000;
// FFBF
		PALETTE[15] <= 12'h000;
// FFC0 / FFC1
		V[0] <= 1'b0;
// FFC2 / FFC3
		V[1] <= 1'b0;
// FFC4 / FFC5
		V[2] <= 1'b0;
// FFC6 / FFC7
		VERT[0] <= 1'b0;
// FFC8 / FFC9
		VERT[1] <= 1'b0;
// FFCA / FFCB
		VERT[2] <= 1'b0;
// FFCC / FFCD
		VERT[3] <= 1'b0;
// FFCE / FFCF
		VERT[4] <= 1'b0;
// FFD0 / FFD1
		VERT[5] <= 1'b0;
// FFD2 / FFD3
		VERT[6] <= 1'b0;
// FFD4
//		PALETTE_BANK <= 4'h0;
// FFD8 / FFD9
		RATE <= 1'b0;
// FFDE / FFDF
		RAM <= 1'b0;
	end
	else
	begin
		if(!RW_N)
		begin
			case (ADDRESS)
			16'hFF00:
			begin
				if(!DDR1)
					DD_REG1 <= DATA_OUT;
			end
			16'hFF01:
			begin
					HSYNC_INT <= DATA_OUT[0];
					HSYNC_POL <= DATA_OUT[1];
					DDR1 <= DATA_OUT[2];
					SEL[0] <= DATA_OUT[3];
			end
			16'hFF02:
			begin
				if(!DDR2)
					DD_REG2 <= DATA_OUT;
				else
					KEY_COLUMN <= DATA_OUT;
			end
			16'hFF03:
			begin
				VSYNC_INT <= DATA_OUT[0];
				VSYNC_POL <= DATA_OUT[1];
				DDR2 <= DATA_OUT[2];
				SEL[1] <= DATA_OUT[3];
			end
			16'hFF04:
			begin
				if(!DDR1)
					DD_REG1 <= DATA_OUT;
			end
			16'hFF05:
			begin
					HSYNC_INT <= DATA_OUT[0];
					HSYNC_POL <= DATA_OUT[1];
					DDR1 <= DATA_OUT[2];
					SEL[0] <= DATA_OUT[3];
			end
			16'hFF06:
			begin
				if(!DDR2)
					DD_REG2 <= DATA_OUT;
				else
					KEY_COLUMN <= DATA_OUT;
			end
			16'hFF07:
			begin
				VSYNC_INT <= DATA_OUT[0];
				VSYNC_POL <= DATA_OUT[1];
				DDR2 <= DATA_OUT[2];
				SEL[1] <= DATA_OUT[3];
			end
			16'hFF08:
			begin
				if(!DDR1)
					DD_REG1 <= DATA_OUT;
			end
			16'hFF09:
			begin
					HSYNC_INT <= DATA_OUT[0];
					HSYNC_POL <= DATA_OUT[1];
					DDR1 <= DATA_OUT[2];
					SEL[0] <= DATA_OUT[3];
			end
			16'hFF0A:
			begin
				if(!DDR2)
					DD_REG2 <= DATA_OUT;
				else
					KEY_COLUMN <= DATA_OUT;
			end
			16'hFF0B:
			begin
				VSYNC_INT <= DATA_OUT[0];
				VSYNC_POL <= DATA_OUT[1];
				DDR2 <= DATA_OUT[2];
				SEL[1] <= DATA_OUT[3];
			end
			16'hFF0C:
			begin
				if(!DDR1)
					DD_REG1 <= DATA_OUT;
			end
			16'hFF0D:
			begin
					HSYNC_INT <= DATA_OUT[0];
					HSYNC_POL <= DATA_OUT[1];
					DDR1 <= DATA_OUT[2];
					SEL[0] <= DATA_OUT[3];
			end
			16'hFF0E:
			begin
				if(!DDR2)
					DD_REG2 <= DATA_OUT;
				else
					KEY_COLUMN <= DATA_OUT;
			end
			16'hFF0F:
			begin
				VSYNC_INT <= DATA_OUT[0];
				VSYNC_POL <= DATA_OUT[1];
				DDR2 <= DATA_OUT[2];
				SEL[1] <= DATA_OUT[3];
			end
			16'hFF10:
			begin
				if(!DDR1)
					DD_REG1 <= DATA_OUT;
			end
			16'hFF11:
			begin
					HSYNC_INT <= DATA_OUT[0];
					HSYNC_POL <= DATA_OUT[1];
					DDR1 <= DATA_OUT[2];
					SEL[0] <= DATA_OUT[3];
			end
			16'hFF12:
			begin
				if(!DDR2)
					DD_REG2 <= DATA_OUT;
				else
					KEY_COLUMN <= DATA_OUT;
			end
			16'hFF13:
			begin
				VSYNC_INT <= DATA_OUT[0];
				VSYNC_POL <= DATA_OUT[1];
				DDR2 <= DATA_OUT[2];
				SEL[1] <= DATA_OUT[3];
			end
			16'hFF14:
			begin
				if(!DDR1)
					DD_REG1 <= DATA_OUT;
			end
			16'hFF15:
			begin
					HSYNC_INT <= DATA_OUT[0];
					HSYNC_POL <= DATA_OUT[1];
					DDR1 <= DATA_OUT[2];
					SEL[0] <= DATA_OUT[3];
			end
			16'hFF16:
			begin
				if(!DDR2)
					DD_REG2 <= DATA_OUT;
				else
					KEY_COLUMN <= DATA_OUT;
			end
			16'hFF17:
			begin
				VSYNC_INT <= DATA_OUT[0];
				VSYNC_POL <= DATA_OUT[1];
				DDR2 <= DATA_OUT[2];
				SEL[1] <= DATA_OUT[3];
			end
			16'hFF18:
			begin
				if(!DDR1)
					DD_REG1 <= DATA_OUT;
			end
			16'hFF19:
			begin
					HSYNC_INT <= DATA_OUT[0];
					HSYNC_POL <= DATA_OUT[1];
					DDR1 <= DATA_OUT[2];
					SEL[0] <= DATA_OUT[3];
			end
			16'hFF1A:
			begin
				if(!DDR2)
					DD_REG2 <= DATA_OUT;
				else
					KEY_COLUMN <= DATA_OUT;
			end
			16'hFF1B:
			begin
				VSYNC_INT <= DATA_OUT[0];
				VSYNC_POL <= DATA_OUT[1];
				DDR2 <= DATA_OUT[2];
				SEL[1] <= DATA_OUT[3];
			end
			16'hFF1C:
			begin
				if(!DDR1)
					DD_REG1 <= DATA_OUT;
			end
			16'hFF1D:
			begin
					HSYNC_INT <= DATA_OUT[0];
					HSYNC_POL <= DATA_OUT[1];
					DDR1 <= DATA_OUT[2];
					SEL[0] <= DATA_OUT[3];
			end
			16'hFF1E:
			begin
				if(!DDR2)
					DD_REG2 <= DATA_OUT;
				else
					KEY_COLUMN <= DATA_OUT;
			end
			16'hFF1F:
			begin
				VSYNC_INT <= DATA_OUT[0];
				VSYNC_POL <= DATA_OUT[1];
				DDR2 <= DATA_OUT[2];
				SEL[1] <= DATA_OUT[3];
			end
			16'hFF20:
			begin
				if(!DDR3)
					DD_REG3 <= DATA_OUT;
				else
				begin
					DTOA_CODE <= DATA_OUT[7:2];
					if({SOUND_EN,SEL} == 3'b100)
						SOUND_DTOA <= DATA_OUT[7:2];
	//				BBTXD <= DATA_OUT[1];
				end
			end
			16'hFF21:
			begin
				CD_INT <= DATA_OUT[0];
				CD_POL <= DATA_OUT[1];
				DDR3 <= DATA_OUT[2];
				CAS_MTR <= DATA_OUT[3];
			end
			16'hFF22:
			begin
				if(!DDR4)
					DD_REG4 <= DATA_OUT;
				else
					SBS <= DATA_OUT[1];
					CSS <= DATA_OUT[3];
					VDG_CONTROL <= DATA_OUT[7:4];
			end
			16'hFF23:
			begin
				CART_INT <= DATA_OUT[0];
				CART_POL <= DATA_OUT[1];
				DDR4 <= DATA_OUT[2];
				SOUND_EN <= DATA_OUT[3];
			end
			16'hFF24:
			begin
				if(!DDR3)
					DD_REG3 <= DATA_OUT;
				else
				begin
					DTOA_CODE <= DATA_OUT[7:2];
					if({SOUND_EN,SEL} == 3'b100)
						SOUND_DTOA <= DATA_OUT[7:2];
	//				BBTXD <= DATA_OUT[1];
				end
			end
			16'hFF25:
			begin
				CD_INT <= DATA_OUT[0];
				CD_POL <= DATA_OUT[1];
				DDR3 <= DATA_OUT[2];
				CAS_MTR <= DATA_OUT[3];
			end
			16'hFF26:
			begin
				if(!DDR4)
					DD_REG4 <= DATA_OUT;
				else
					SBS <= DATA_OUT[1];
					CSS <= DATA_OUT[3];
					VDG_CONTROL <= DATA_OUT[7:4];
			end
			16'hFF27:
			begin
				CART_INT <= DATA_OUT[0];
				CART_POL <= DATA_OUT[1];
				DDR4 <= DATA_OUT[2];
				SOUND_EN <= DATA_OUT[3];
			end
			16'hFF28:
			begin
				if(!DDR3)
					DD_REG3 <= DATA_OUT;
				else
				begin
					DTOA_CODE <= DATA_OUT[7:2];
					if({SOUND_EN,SEL} == 3'b100)
						SOUND_DTOA <= DATA_OUT[7:2];
	//				BBTXD <= DATA_OUT[1];
				end
			end
			16'hFF29:
			begin
				CD_INT <= DATA_OUT[0];
				CD_POL <= DATA_OUT[1];
				DDR3 <= DATA_OUT[2];
				CAS_MTR <= DATA_OUT[3];
			end
			16'hFF2A:
			begin
				if(!DDR4)
					DD_REG4 <= DATA_OUT;
				else
					SBS <= DATA_OUT[1];
					CSS <= DATA_OUT[3];
					VDG_CONTROL <= DATA_OUT[7:4];
			end
			16'hFF2B:
			begin
				CART_INT <= DATA_OUT[0];
				CART_POL <= DATA_OUT[1];
				DDR4 <= DATA_OUT[2];
				SOUND_EN <= DATA_OUT[3];
			end
			16'hFF2C:
			begin
				if(!DDR3)
					DD_REG3 <= DATA_OUT;
				else
				begin
					DTOA_CODE <= DATA_OUT[7:2];
					if({SOUND_EN,SEL} == 3'b100)
						SOUND_DTOA <= DATA_OUT[7:2];
	//				BBTXD <= DATA_OUT[1];
				end
			end
			16'hFF2D:
			begin
				CD_INT <= DATA_OUT[0];
				CD_POL <= DATA_OUT[1];
				DDR3 <= DATA_OUT[2];
				CAS_MTR <= DATA_OUT[3];
			end
			16'hFF2E:
			begin
				if(!DDR4)
					DD_REG4 <= DATA_OUT;
				else
					SBS <= DATA_OUT[1];
					CSS <= DATA_OUT[3];
					VDG_CONTROL <= DATA_OUT[7:4];
			end
			16'hFF2F:
			begin
				CART_INT <= DATA_OUT[0];
				CART_POL <= DATA_OUT[1];
				DDR4 <= DATA_OUT[2];
				SOUND_EN <= DATA_OUT[3];
			end
			16'hFF30:
			begin
				if(!DDR3)
					DD_REG3 <= DATA_OUT;
				else
				begin
					DTOA_CODE <= DATA_OUT[7:2];
					if({SOUND_EN,SEL} == 3'b100)
						SOUND_DTOA <= DATA_OUT[7:2];
	//				BBTXD <= DATA_OUT[1];
				end
			end
			16'hFF31:
			begin
				CD_INT <= DATA_OUT[0];
				CD_POL <= DATA_OUT[1];
				DDR3 <= DATA_OUT[2];
				CAS_MTR <= DATA_OUT[3];
			end
			16'hFF32:
			begin
				if(!DDR4)
					DD_REG4 <= DATA_OUT;
				else
					SBS <= DATA_OUT[1];
					CSS <= DATA_OUT[3];
					VDG_CONTROL <= DATA_OUT[7:4];
			end
			16'hFF33:
			begin
				CART_INT <= DATA_OUT[0];
				CART_POL <= DATA_OUT[1];
				DDR4 <= DATA_OUT[2];
				SOUND_EN <= DATA_OUT[3];
			end
			16'hFF34:
			begin
				if(!DDR3)
					DD_REG3 <= DATA_OUT;
				else
				begin
					DTOA_CODE <= DATA_OUT[7:2];
					if({SOUND_EN,SEL} == 3'b100)
						SOUND_DTOA <= DATA_OUT[7:2];
	//				BBTXD <= DATA_OUT[1];
				end
			end
			16'hFF35:
			begin
				CD_INT <= DATA_OUT[0];
				CD_POL <= DATA_OUT[1];
				DDR3 <= DATA_OUT[2];
				CAS_MTR <= DATA_OUT[3];
			end
			16'hFF36:
			begin
				if(!DDR4)
					DD_REG4 <= DATA_OUT;
				else
					SBS <= DATA_OUT[1];
					CSS <= DATA_OUT[3];
					VDG_CONTROL <= DATA_OUT[7:4];
			end
			16'hFF37:
			begin
				CART_INT <= DATA_OUT[0];
				CART_POL <= DATA_OUT[1];
				DDR4 <= DATA_OUT[2];
				SOUND_EN <= DATA_OUT[3];
			end
			16'hFF38:
			begin
				if(!DDR3)
					DD_REG3 <= DATA_OUT;
				else
				begin
					DTOA_CODE <= DATA_OUT[7:2];
					if({SOUND_EN,SEL} == 3'b100)
						SOUND_DTOA <= DATA_OUT[7:2];
	//				BBTXD <= DATA_OUT[1];
				end
			end
			16'hFF39:
			begin
				CD_INT <= DATA_OUT[0];
				CD_POL <= DATA_OUT[1];
				DDR3 <= DATA_OUT[2];
				CAS_MTR <= DATA_OUT[3];
			end
			16'hFF3A:
			begin
				if(!DDR4)
					DD_REG4 <= DATA_OUT;
				else
					SBS <= DATA_OUT[1];
					CSS <= DATA_OUT[3];
					VDG_CONTROL <= DATA_OUT[7:4];
			end
			16'hFF3B:
			begin
				CART_INT <= DATA_OUT[0];
				CART_POL <= DATA_OUT[1];
				DDR4 <= DATA_OUT[2];
				SOUND_EN <= DATA_OUT[3];
			end
			16'hFF3C:
			begin
				if(!DDR3)
					DD_REG3 <= DATA_OUT;
				else
				begin
					DTOA_CODE <= DATA_OUT[7:2];
					if({SOUND_EN,SEL} == 3'b100)
						SOUND_DTOA <= DATA_OUT[7:2];
	//				BBTXD <= DATA_OUT[1];
				end
			end
			16'hFF3D:
			begin
				CD_INT <= DATA_OUT[0];
				CD_POL <= DATA_OUT[1];
				DDR3 <= DATA_OUT[2];
				CAS_MTR <= DATA_OUT[3];
			end
			16'hFF3E:
			begin
				if(!DDR4)
					DD_REG4 <= DATA_OUT;
				else
					SBS <= DATA_OUT[1];
					CSS <= DATA_OUT[3];
					VDG_CONTROL <= DATA_OUT[7:4];
			end
			16'hFF3F:
			begin
				CART_INT <= DATA_OUT[0];
				CART_POL <= DATA_OUT[1];
				DDR4 <= DATA_OUT[2];
				SOUND_EN <= DATA_OUT[3];
			end
			16'hFF6C:
			begin
				WF_IRQ_EN <= DATA_OUT[7];
				WF_BAUD <= DATA_OUT[0];
			end
			16'hFF70:
			begin
				GART_WRITE[22:16] <= DATA_OUT[6:0];	//2MB    512Kb: GART_WRITE[18:16] <= DATA_OUT[2:0];
			end
			16'hFF71:
			begin
				GART_WRITE[15:8] <= DATA_OUT;
			end
			16'hFF72:
			begin
				GART_WRITE[7:0] <= DATA_OUT;
			end
			16'hFF73:
			begin
				if(GART_INC[0])
					GART_WRITE <= GART_WRITE + 1'b1;
			end
			16'hFF74:
			begin
				GART_READ[22:16] <= DATA_OUT[6:0];	//2MB     512:GART_READ[18:16] <= DATA_OUT[2:0];
			end
			16'hFF75:
			begin
				GART_READ[15:8] <= DATA_OUT;
			end
			16'hFF76:
			begin
				GART_READ[7:0] <= DATA_OUT;
			end
			16'hFF77:
			begin
				GART_INC <= DATA_OUT[1:0];
			end
			16'hFF78:
			begin
				GART_CNT[16:9] <= DATA_OUT;
			end
			16'hFF79:
			begin
				GART_CNT[8:0] <= {DATA_OUT,1'b0};
			end
			16'hFF7A:
			begin
				ORCH_LEFT <= DATA_OUT;
				ORCH_LEFT_EXT <= ORCH_LEFT_EXT_BUF;
			end
			16'hFF7B:
			begin
				ORCH_RIGHT <= DATA_OUT;
				ORCH_RIGHT_EXT <= ORCH_RIGHT_EXT_BUF;
			end
			16'hFF7C:
				ORCH_LEFT_EXT_BUF <= DATA_OUT;
			16'hFF7D:
				ORCH_RIGHT_EXT_BUF <= DATA_OUT;
			16'hFF7F:
			begin
				W_PROT[0] <=  DATA_OUT[2] | !DATA_OUT[3];
				W_PROT[1] <= !DATA_OUT[2] |  DATA_OUT[3] | W_PROT[0];
				MPI_SCS <= DATA_OUT[1:0];
				MPI_CTS <= DATA_OUT[5:4];
			end
			16'hFF80:
			begin
				CK_START <= DATA_OUT[0];
			end
			16'hFF81:
			begin
				CK_DATA_OUT <= DATA_OUT;
			end
			16'hFF82:
			begin
				CK_DEVICE <= DATA_OUT;
			end
			16'hFF83:
			begin
				CK_REG <= DATA_OUT;
			end
			16'hFF84:
			begin
				SDRAM_READ <= DATA_OUT[0];
			end
			16'hFF85:
			begin
				SDRAM_DIN[7:0] <= DATA_OUT;
			end
			16'hFF86:
			begin
				SDRAM_DIN[15:8] <= DATA_OUT;
			end
			16'hFF87:
			begin
				SDRAM_ADDR[14:7] <= DATA_OUT;
			end
			16'hFF88:
			begin
				SDRAM_ADDR[21:15] <= DATA_OUT[6:0];
			end
			16'hFF90:
			begin
				ROM <= DATA_OUT[1:0];
				ST_SCS <= DATA_OUT[2];
				VEC_PAG_RAM <= DATA_OUT[3];
				GIME_FIRQ <= DATA_OUT[4];
				GIME_IRQ <= DATA_OUT[5];
				MMU_EN <= DATA_OUT[6];
				COCO1 <= DATA_OUT[7];
			end
			16'hFF91:
			begin
				TIMER_INS <= DATA_OUT[5];
				MMU_TR <= DATA_OUT[0];
			end
			16'hFF92:
			begin
				IRQ_TMR <= DATA_OUT[5];
				IRQ_HBORD <= DATA_OUT[4];
				IRQ_VBORD <= DATA_OUT[3];
//				IRQ_SERIAL <= DATA_OUT[2];
				IRQ_KEY <= DATA_OUT[1];
				IRQ_CART <= DATA_OUT[0];
			end
			16'hFF93:
			begin
				FIRQ_TMR <= DATA_OUT[5];
				FIRQ_HBORD <= DATA_OUT[4];
				FIRQ_VBORD <= DATA_OUT[3];
//				FIRQ_SERIAL <= DATA_OUT[2];
				FIRQ_KEY <= DATA_OUT[1];
				FIRQ_CART <= DATA_OUT[0];
			end
			16'hFF94:
			begin
				TMR_MSB <= DATA_OUT[3:0];
				TMR_ENABLE <= 1'b1;
			end
			16'hFF95:
			begin
				TMR_LSB <= DATA_OUT;
			end
			16'hFF98:
			begin
				GRMODE <= DATA_OUT[7];
				HRES[3] <= DATA_OUT[6];	// Extended resolutions
				DESCEN <= DATA_OUT[5];
				MONO <= DATA_OUT[4];
				LPR <= DATA_OUT[2:0];
			end
			16'hFF99:
			begin
				HLPR <= DATA_OUT[7];
				LPF <= DATA_OUT[6:5];
				HRES[2:0] <= DATA_OUT[4:2];
				CRES <= DATA_OUT[1:0];
			end
			16'hFF9A:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[16][5:0] <= DATA_OUT[5:0];
					PALETTE[16][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[16][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFF9B:
			begin
				SCRN_START_HSB <= DATA_OUT[3:0];	// extra 4 bits for 8MB screen start
				SAM_EXT <= DATA_OUT[5:4];
			end
			16'hFF9C:
			begin
				VERT_FIN_SCRL <= DATA_OUT[3:0];
			end
			16'hFF9D:
			begin
				SCRN_START_MSB <= DATA_OUT;
			end
			16'hFF9E:
			begin
				SCRN_START_LSB <= DATA_OUT;
			end
			16'hFF9F:
			begin
				HVEN <= DATA_OUT[7];
				HOR_OFFSET <= DATA_OUT[6:0];
			end
			16'hFFA0:
			begin
				SAM00 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFA1:
			begin
				SAM01 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFA2:
			begin
				SAM02 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFA3:
			begin
				SAM03 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFA4:
			begin
				SAM04 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFA5:
			begin
				SAM05 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFA6:
			begin
				SAM06 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFA7:
			begin
				SAM07 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFA8:
			begin
				SAM10 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFA9:
			begin
				SAM11 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFAA:
			begin
				SAM12 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFAB:
			begin
				SAM13 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFAC:
			begin
				SAM14 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFAD:
			begin
				SAM15 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFAE:
			begin
				SAM16 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFAF:
			begin
				SAM17 <= {SAM_EXT,DATA_OUT[7:0]};
			end
			16'hFFB0:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[0][5:0] <= DATA_OUT[5:0];
					PALETTE[0][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[0][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFB1:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[1][5:0] <= DATA_OUT[5:0];
					PALETTE[1][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[1][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFB2:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[2][5:0] <= DATA_OUT[5:0];
					PALETTE[2][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[2][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFB3:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[3][5:0] <= DATA_OUT[5:0];
					PALETTE[3][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[3][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFB4:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[4][5:0] <= DATA_OUT[5:0];
					PALETTE[4][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[4][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFB5:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[5][5:0] <= DATA_OUT[5:0];
					PALETTE[5][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[5][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFB6:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[6][5:0] <= DATA_OUT[5:0];
					PALETTE[6][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[6][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFB7:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[7][5:0] <= DATA_OUT[5:0];
					PALETTE[7][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[7][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFB8:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[8][5:0] <= DATA_OUT[5:0];
					PALETTE[8][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[8][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFB9:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[9][5:0] <= DATA_OUT[5:0];
					PALETTE[9][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[9][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFBA:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[10][5:0] <= DATA_OUT[5:0];
					PALETTE[10][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[10][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFBB:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[11][5:0] <= DATA_OUT[5:0];
					PALETTE[11][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[11][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFBC:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[12][5:0] <= DATA_OUT[5:0];
					PALETTE[12][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[12][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFBD:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[13][5:0] <= DATA_OUT[5:0];
					PALETTE[13][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[13][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFBE:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[14][5:0] <= DATA_OUT[5:0];
					PALETTE[14][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[14][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFBF:
			begin
				if(!DATA_OUT[7])
				begin
					PALETTE[15][5:0] <= DATA_OUT[5:0];
					PALETTE[15][11:6] <= DATA_OUT[5:0];
				end
				else
				begin
					PALETTE[15][5:0] <= DATA_OUT[5:0];
				end
			end
			16'hFFC0:
			begin
				V[0] <= 1'b0;
			end
			16'hFFC1:
			begin
				V[0] <= 1'b1;
			end
			16'hFFC2:
			begin
				V[1] <= 1'b0;
			end
			16'hFFC3:
			begin
				V[1] <= 1'b1;
			end
			16'hFFC4:
			begin
				V[2] <= 1'b0;
			end
			16'hFFC5:
			begin
				V[2] <= 1'b1;
			end
			16'hFFC6:
			begin
				VERT[0] <= 1'b0;
			end
			16'hFFC7:
			begin
				VERT[0] <= 1'b1;
			end
			16'hFFC8:
			begin
				VERT[1] <= 1'b0;
			end
			16'hFFC9:
			begin
				VERT[1] <= 1'b1;
			end
			16'hFFCA:
			begin
				VERT[2] <= 1'b0;
			end
			16'hFFCB:
			begin
				VERT[2] <= 1'b1;
			end
			16'hFFCC:
			begin
				VERT[3] <= 1'b0;
			end
			16'hFFCD:
			begin
				VERT[3] <= 1'b1;
			end
			16'hFFCE:
			begin
				VERT[4] <= 1'b0;
			end
			16'hFFCF:
			begin
				VERT[4] <= 1'b1;
			end
			16'hFFD0:
			begin
				VERT[5] <= 1'b0;
			end
			16'hFFD1:
			begin
				VERT[5] <= 1'b1;
			end
			16'hFFD2:
			begin
				VERT[6] <= 1'b0;
			end
			16'hFFD3:
			begin
				VERT[6] <= 1'b1;
			end
			16'hFFD8:
			begin
				RATE <= 1'b0;
			end
			16'hFFD9:
			begin
				RATE <= 1'b1;
			end
			16'hFFDE:
			begin
				RAM <= 1'b0;
			end
			16'hFFDF:
			begin
				RAM <= 1'b1;
			end
//			default:
//			begin
//				if(!VMA & GART_CNT !=16'h0000)
//				begin
//					GART_CNT <= GART_CNT - 1'b1;
//				end
//			end
			endcase
		end
		else
		begin
			if(ADDRESS == 16'hFF73)
			begin
				if(GART_INC[1])
					GART_READ <= GART_READ + 1'b1;
			end
			else
			begin
				if(!VMA & (GART_CNT != 17'h00000))
				begin
					GART_CNT <= GART_CNT - 1'b1;
					if(GART_CNT[0] & GART_INC[0])
						GART_WRITE <= GART_WRITE + 1'b1;
					else
						if(!GART_CNT[0] & GART_INC[1])
							GART_READ <= GART_READ + 1'b1;
				end
			end
		end
	end
end

// The code for the internal and Orchestra sound
`include "..\CoCo3FPGA_Common\sound.v"
// The code for the paddles
`include "..\CoCo3FPGA_Common\paddles.v"

/*****************************************************************************
* Convert PS/2 keyboard to CoCo keyboard
* Buttons
* 0 left 1
* 1 left 2
* 2 right 2
* 3 right 1
******************************************************************************/
assign KEYBOARD_IN[0] =  !((!KEY_COLUMN[0] & KEY[0])				// @
								 | (!KEY_COLUMN[1] & KEY[1])				// A
								 | (!KEY_COLUMN[2] & KEY[2])				// B
								 | (!KEY_COLUMN[3] & KEY[3])				// C
								 | (!KEY_COLUMN[4] & KEY[4])				// D
								 | (!KEY_COLUMN[5] & KEY[5])				// E
								 | (!KEY_COLUMN[6] & KEY[6])				// F
								 | (!KEY_COLUMN[7] & KEY[7])				// G
								 | !P_SWITCH[3]);								// Right Joystick Switch 1
//								 | (!SWITCH[5]     & !P_SWITCH[3])		// Right Joystick Switch 1
//								 | ( SWITCH[5]     & !P_SWITCH[0]));	// Left Joystick Switch 1

assign KEYBOARD_IN[1] =	 !((!KEY_COLUMN[0] & KEY[8])				// H
								 | (!KEY_COLUMN[1] & KEY[9])				// I
								 | (!KEY_COLUMN[2] & KEY[10])				// J
								 | (!KEY_COLUMN[3] & KEY[11])				// K
								 | (!KEY_COLUMN[4] & KEY[12])				// L
								 | (!KEY_COLUMN[5] & KEY[13])				// M
								 | (!KEY_COLUMN[6] & KEY[14])				// N
								 | (!KEY_COLUMN[7] & KEY[15])				// O
								 | !P_SWITCH[0]);								// Left Joystick Switch 1
//								 | (!SWITCH[5]     & !P_SWITCH[0])		// Left Joystick Switch 1
//								 | ( SWITCH[5]     & !P_SWITCH[3]));	// Right Joystick Switch 1

assign KEYBOARD_IN[2] =	 !((!KEY_COLUMN[0] & KEY[16])				// P
								 | (!KEY_COLUMN[1] & KEY[17])				// Q
								 | (!KEY_COLUMN[2] & KEY[18])				// R
								 | (!KEY_COLUMN[3] & KEY[19])				// S
								 | (!KEY_COLUMN[4] & KEY[20])				// T
								 | (!KEY_COLUMN[5] & KEY[21])				// U
								 | (!KEY_COLUMN[6] & KEY[22])				// V
								 | (!KEY_COLUMN[7] & KEY[23])				// W
								 | !P_SWITCH[2]);								// Left Joystick Switch 2
//								 | (!SWITCH[5]     & !P_SWITCH[2])		// Left Joystick Switch 2
//								 | ( SWITCH[5]     & !P_SWITCH[1]));	// Right Joystick Switch 2

assign KEYBOARD_IN[3] =	 !((!KEY_COLUMN[0] & KEY[24])				// X
								 | (!KEY_COLUMN[1] & KEY[25])				// Y
								 | (!KEY_COLUMN[2] & KEY[26])				// Z
								 | (!KEY_COLUMN[3] & KEY[27])				// up
								 | (!KEY_COLUMN[4] & KEY[28])				// down
								 | (!KEY_COLUMN[5] & KEY[29])				// Backspace & left
								 | (!KEY_COLUMN[6] & KEY[30])				// right
								 | (!KEY_COLUMN[7] & KEY[31])				// space
								 | !P_SWITCH[1]);								// Right Joystick Switch 2
//								 | (!SWITCH[5]     & !P_SWITCH[1])		// Right Joystick Switch 2
//								 | ( SWITCH[5]     & !P_SWITCH[2]));	// Left Joystick Switch 2

assign KEYBOARD_IN[4] =	 !((!KEY_COLUMN[0] & KEY[32])				// 0
								 | (!KEY_COLUMN[1] & KEY[33])				// 1
								 | (!KEY_COLUMN[2] & KEY[34])				// 2
								 | (!KEY_COLUMN[3] & KEY[35])				// 3
								 | (!KEY_COLUMN[4] & KEY[36])				// 4
								 | (!KEY_COLUMN[5] & KEY[37])				// 5
								 | (!KEY_COLUMN[6] & KEY[38])				// 6
								 | (!KEY_COLUMN[7] & KEY[39]));			// 7

assign KEYBOARD_IN[5] =	 !((!KEY_COLUMN[0] & KEY[40])				// 8
								 | (!KEY_COLUMN[1] & KEY[41])				// 9
								 | (!KEY_COLUMN[2] & KEY[42])				// :
								 | (!KEY_COLUMN[3] & KEY[43])				// ;
								 | (!KEY_COLUMN[4] & KEY[44])				// ,
								 | (!KEY_COLUMN[5] & KEY[45])				// -
								 | (!KEY_COLUMN[6] & KEY[46])				// .
								 | (!KEY_COLUMN[7] & KEY[47]));			// /

assign KEYBOARD_IN[6] =	 !((!KEY_COLUMN[0] & KEY[48])				// CR
								 | (!KEY_COLUMN[1] & KEY[49])				// TAB
								 | (!KEY_COLUMN[2] & KEY[50])				// ESC
								 | (!KEY_COLUMN[3] & KEY[51])				// ALT
								 | (!KEY_COLUMN[3] & !BUTTON_N[0])		// ALT (Easter Egg)
								 | (!KEY_COLUMN[4] & KEY[52])				// CTRL
								 | (!KEY_COLUMN[4] & !BUTTON_N[0])		// CTRL (Easter Egg)
								 | (!KEY_COLUMN[5] & KEY[53])				// F1
								 | (!KEY_COLUMN[6] & KEY[54])				// F2
								 | (!KEY_COLUMN[7] & KEY[55] & !SHIFT_OVERRIDE)	// shift
								 |	(!KEY_COLUMN[7] & SHIFT));				// Forced Shift

assign KEYBOARD_IN[7] =	 JSTICK;											// Joystick input

// PS2 Keyboard interface
COCOKEY coco_keyboard(
		.RESET_N(RESET_N),
		.CLK50MHZ(CLK50MHZ),
		.SLO_CLK(V_SYNC),
		.PS2_CLK(ps2_clk),
		.PS2_DATA(ps2_data),
		.KEY(KEY),
		.SHIFT(SHIFT),
		.SHIFT_OVERRIDE(SHIFT_OVERRIDE),
		.RESET(RESET)
);
/*****************************************************************************
* Video
******************************************************************************/
// Request for every other line to be black
// Looks more like the original video
always @ (negedge H_SYNC or negedge V_SYNC)
begin
	if(!V_SYNC)
		ODD_LINE <= 1'b0;
	else
		if(!ODD_LINE & SWITCH[3])
			ODD_LINE <= 1'b1;
		else
			ODD_LINE <= 1'b0;
end


// Video DAC
always @ (negedge MCLOCK[0])
begin
	COLOR_BUF <= COLOR;							// Delay COLOR by 1 clock cycle to align with 256 Color SRAM
	H_SYNC <= H_SYNC_X;							// Delay H_SYNC by 1 clock cycle
	V_SYNC <= V_SYNC_X;							// Delay V_SYNC by 1 clock cycle
	if(ODD_LINE | COLOR_BUF[9])				// Odd lines or retrace Black
	begin
		{RED3, GREEN3, BLUE3, RED2, GREEN2, BLUE2, RED1, GREEN1, BLUE1, RED0, GREEN0, BLUE0} <= 12'h000;
	end
	else
	begin
		if(COLOR_BUF[8])
		begin
				{RED3, GREEN3, BLUE3, RED2, GREEN2, BLUE2, RED1, GREEN1, BLUE1, RED0, GREEN0, BLUE0} <= VDAC_OUT[11:0];
		end
		else
		begin
			RED3 <= PALETTE[COLOR_BUF[4:0]][11];
			RED2 <= PALETTE[COLOR_BUF[4:0]][8];
			RED1 <= PALETTE[COLOR_BUF[4:0]][5];
			RED0 <= PALETTE[COLOR_BUF[4:0]][2];
			GREEN3 <= PALETTE[COLOR_BUF[4:0]][10];
			GREEN2 <= PALETTE[COLOR_BUF[4:0]][7];
			GREEN1 <= PALETTE[COLOR_BUF[4:0]][4];
			GREEN0 <= PALETTE[COLOR_BUF[4:0]][1];
			BLUE3 <=	PALETTE[COLOR_BUF[4:0]][9];
			BLUE2 <=	PALETTE[COLOR_BUF[4:0]][6];
			BLUE1 <=	PALETTE[COLOR_BUF[4:0]][3];
			BLUE0 <=	PALETTE[COLOR_BUF[4:0]][0];
		end
	end
end

VDAC	VDAC_inst (
	.data ( {4'h0,PALETTE[0][11:0]} ),
	.rdaddress ( COLOR[7:0] ),
	.rdclock ( MCLOCK[0] ),
	.wraddress ( DATA_OUT ),
	.wrclock ( PH_2 ),
	.wren ( VDAC_EN ),
	.q ( VDAC_OUT )
	);

// Video timing and modes
COCO3VIDEO COCOVID(
	.PIX_CLK(MCLOCK[0]),		//25 MHz = 40 nS
	.RESET_N(RESET_N),
	.COLOR(COLOR),
	.HSYNC(H_SYNC_X),
	.SYNC_FLAG(H_FLAG),
	.VSYNC(V_SYNC_X),
	.HBLANKING(HBLANK),
	.VBLANKING(VBLANK),
	.RAM_ADDRESS(VIDEO_ADDRESS),
	.RAM_DATA(VIDEO_BUFFER),
	.COCO(COCO1),
	.V(V),
	.BP(GRMODE),
	.VERT(VERT),
	.VID_CONT(VDG_CONTROL),
	.HVEN(HVEN),
	.HOR_OFFSET(HOR_OFFSET),
	.SCRN_START_HSB(SCRN_START_HSB),		// 2 extra bits for 2MB screen start
	.SCRN_START_MSB(SCRN_START_MSB),
	.SCRN_START_LSB(SCRN_START_LSB),
 	.CSS(CSS),
	.LPF(LPF),
	.VERT_FIN_SCRL(VERT_FIN_SCRL),
	.HLPR(HLPR & !SWITCH[3]),
	.LPR(LPR),
	.HRES(HRES),
	.CRES(CRES),
	.BLINK(BLINK),
	.SWITCH5(SWITCH[5])
);

// RS232PAK UART
glb6551 RS232(
.RESET_N(RESET_N),
.RX_CLK(RX_CLK2),
.RX_CLK_IN(COM2_STATE[0]),
.XTAL_CLK_IN(COM2_STATE[0]),
.PH_2(PH_2),
.DI(DATA_OUT),
.DO(DATA_RS232),
.IRQ(SER_IRQ),
.CS({1'b0, RS232_EN}),
.RW_N(RW_N),
.RS(ADDRESS[1:0]),
.TXDATA_OUT(UART51_TXD),
.RXDATA_IN(UART51_RXD),
.RTS(UART51_RTS),
.CTS(UART51_RTS),
.DCD(UART51_DTR),
.DTR(UART51_DTR),
.DSR(UART51_DTR)
);

/*****************************************************************************
* SD Card interface
******************************************************************************/
SDCard SPI_09(
	.clk_i(MCLOCK[0]),		// 25 MHz Clock means 12.5 MHz SDCard transfers
	.cpuclk_n_i(PH_2),		// CPU Clock
	.reset_n_i(RESET_N),		// reset (asynchronous active low)
	.cs_i(SPI_EN),				// chip select
	.adr_i(ADDRESS[0]),		// address[0]
	.rw_n_i(RW_N),				// write enable
	.dat_i(DATA_OUT),			// data input
	.dat_o(SPI_DATA),			// data output
	.irq_n_o(IRQ_SPI_N),		// irq output (low active)
	.halt_o(SPI_HALT),
  // SPI port
	.act_led_n_o(act_led_n),
	.card_detect_n_i(BUTTON_N[2] & !SWITCH[6]),
	.wp_locked_i(BUTTON_N[1] & !SWITCH[6]),
	.spi_ss_n_o(SPI_SS_N),	// SPI Chip Select
	.sclk_o(SPI_CLK),			// serial clock output
	.mosi_o(MOSI),				// MasterOut SlaveIN
	.miso_i(MISO));			// MasterIn SlaveOut

always @ (negedge PH_2 or negedge RESET_N) 
begin
		if(!RESET_N)
			CK_DONE_BUF <= 2'b00;
		else
			CK_DONE_BUF <= {CK_DONE_BUF[0], CK_DONE};
end

I2C GLB_RTC(
.CLOCK(MCLOCK[6]),
.RESET_N(RESET_N),
.I2C_CLK(CK_CLK),
.I2C_CLK_EN(CK_CLK_EN),
.I2C_DAT(CK_DAT),
.I2C_DAT_EN(CK_DAT_EN),
.DEVICE(CK_DEVICE[7:1]),
.REGISTER(CK_REG),
.DATA_IN(CK_DATA_IN),
.DATA_OUT(CK_DATA_OUT),
.STATE(CK_STATE),
.DONE(CK_DONE),
.FAIL(CK_FAIL),
.RW_N(CK_DEVICE[0]),
.START(CK_START)
);
assign CK_CLK = (CK_CLK_EN == 1'b0) 	?	1'b0:
														1'bZ;

assign CK_DAT = (CK_DAT_EN == 1'b0) 	?	1'b0:
														1'bZ;

endmodule
